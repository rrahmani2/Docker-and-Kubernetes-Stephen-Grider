# **Tutor Notes — Updating and Scaling Kubernetes Deployments**

## Objective

Understand how updating a deployment configuration automatically propagates changes to pods, and how Kubernetes manages scaling and rolling updates.

---

## Step 1: Updating Deployment Configuration

Modify the container port inside the **deployment configuration file**:

```yaml
containers:
  - name: client
    image: <docker-id>/multi-client
    ports:
      - containerPort: 9999
```

### Apply the Change

```bash
kubectl apply -f client-deployment.yaml
```

* Output:
  `deployment.apps/client-deployment configured`
  Indicates the existing deployment was **updated**, not recreated.

### Verify Deployment and Pod Status

```bash
kubectl get deployments
kubectl get pods
```

* Observe:

  * A **new pod** appears with a recent age (e.g., 26 seconds).
  * Kubernetes recognized a **change in the pod template** (container port).
  * The old pod was **terminated**, and a **new pod was created** using the updated configuration.

### Verify Port Change

```bash
kubectl describe pods
```

Check under **Containers → Ports**:

```
Port: 9999/TCP
```

Confirms the pod is running with the new configuration.

> Note: The React app won’t load in the browser now, since it expects port `3000`.

---

## Step 2: Scaling the Deployment

Update replicas in the deployment file:

```yaml
spec:
  replicas: 5
```

### Apply and Verify

```bash
kubectl apply -f client-deployment.yaml
kubectl get deployments
```

You’ll see:

```
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
client-deployment  5/5     5            5           2m
```

Then confirm pod creation:

```bash
kubectl get pods
```

Output:

```
client-deployment-xxxxx   Running
client-deployment-xxxxx   Running
client-deployment-xxxxx   Running
client-deployment-xxxxx   Running
client-deployment-xxxxx   Running
```

Each pod is running a separate container instance of the **multi-client** image.

---

## Step 3: Updating the Container Image

Change image name in the deployment file:

```yaml
containers:
  - name: client
    image: <docker-id>/multi-worker
```

### Apply and Observe Rolling Update

Run:

```bash
kubectl apply -f client-deployment.yaml
kubectl get deployments
```

You may briefly see:

```
NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE
client-deployment  5         7         4            4
```

Interpretation:

* **Desired (5):** Total pods the deployment aims to maintain.
* **Current (7):** Temporary state — old and new pods coexisting during update.
* **Up-to-date (4):** Pods running the **new image** (`multi-worker`).
* **Available (4):** Number of ready pods from the new version.
* The remaining **3 old pods** (7−4) will be terminated after successful rollout.

Recheck after a few seconds:

```bash
kubectl get deployments
```

Now all fields should read `5`, meaning the rollout is complete and all pods are running the **new configuration**.

---

## Step 4: Summary of Deployment Behavior

| Action                                          | Kubernetes Response                                                                             |
| ----------------------------------------------- | ----------------------------------------------------------------------------------------------- |
| **Configuration change (e.g., container port)** | Deletes existing pods and recreates new ones with updated specs.                                |
| **Scaling replicas**                            | Creates or removes pods to match the specified count.                                           |
| **Image update**                                | Performs a **rolling update** — gradually replaces old pods with new ones.                      |
| **Apply command**                               | `kubectl apply -f <file>` always syncs cluster state with the YAML configuration declaratively. |

---

### Key Takeaways

* Deployments manage **pod lifecycle automatically** — updates, rollbacks, and scaling.
* Each change in the **template section** triggers Kubernetes to **recreate pods**.
* **Rolling updates** ensure zero downtime during image or configuration changes.
* `kubectl get deployments` gives real-time insight into rollout progress.
