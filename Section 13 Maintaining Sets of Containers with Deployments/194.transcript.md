# **Tutor Notes — Create Deployment (`client-deployment.yml`)**

## Objective

Create a **Deployment** that manages pods running the `multi-client` image and exposes container port **3000**. Deployments manage pod lifecycle, enable full config updates, rolling updates and are the production-appropriate primitive (instead of using raw Pod objects).

---

## Exact file (copy & save as `client-deployment.yml`)

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: client-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      component: web
  template:
    metadata:
      labels:
        component: web
    spec:
      containers:
        - name: client
          image: your-docker-id/multi-client:latest
          ports:
            - containerPort: 3000
```

Replace `your-docker-id` with your Docker Hub username. Keeping `:latest` explicit is recommended.

---

## Field-by-field (concise)

* **`apiVersion: apps/v1`**
  Deployment resources live in the `apps` API group; use `apps/v1` for `Deployment`.

* **`kind: Deployment`**
  Declares the object type. Deployment manages a ReplicaSet → Pods.

* **`metadata.name`**
  Logical name of this Deployment (`client-deployment`). Used to identify and update this object.

* **`spec.replicas`**
  Desired number of pod replicas to run (1). Master will ensure this count.

* **`spec.selector.matchLabels`**
  Selector used to identify Pods this Deployment owns. **This must match** the pod template’s labels exactly. It’s the Deployment → Pod binding.

* **`spec.template`**
  Pod template: the spec used to create each Pod the Deployment manages.

  * **`template.metadata.labels`** — labels applied to created Pods (must match selector).
  * **`template.spec.containers`** — container list for each Pod.

* **Container block**

  * **`name`** — local container identifier within the Pod (useful for logging, exec).
  * **`image`** — Docker image to run. Change this tag and `kubectl apply -f` to trigger rolling updates.
  * **`ports.containerPort`** — port the container listens on (3000). `targetPort`/Service mapping handled by Service object.

---

## Apply & verify (commands)

```bash
kubectl apply -f client-deployment.yml
kubectl get deployments client-deployment
kubectl get pods -l component=web
kubectl describe deployment client-deployment
```

* Deployment creation returns `created` / `configured`.
* Use `kubectl get pods -l component=web` to see pods controlled by the Deployment.
* To expose the Deployment externally, use a Service (NodePort / LoadBalancer / Ingress) with a selector matching `component: web`.

---

## Notes / Best practices (brief)

* **Do not** change `selector.matchLabels` after creation — that breaks ownership. Define it once to match the template labels.
* Use Deployments rather than raw Pods for updates that modify immutable pod fields (ports, volumes, env, etc.). Deployment will recreate Pods to apply those changes.
* Keep configs in version control and perform changes by editing YAML and `kubectl apply -f`.
* For rolling updates, change `image` tag and re-apply; Deployment performs rolling update by default.

---

Ready for the next step: convert the existing Pod + Service into this Deployment + Service and apply; or I can produce the matching `Service` YAML that selects `component: web` and maps nodePort → targetPort 3000. Which do you want now?
