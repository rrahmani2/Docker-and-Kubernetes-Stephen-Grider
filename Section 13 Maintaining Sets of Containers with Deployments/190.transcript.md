### Declarative Update Example — Updating an Existing Pod

#### 1. Objective

* Update an **existing Kubernetes pod** from using the `multi-client` image to the `multi-worker` image.
* Maintain the same **`name`** and **`kind`** in the configuration file to ensure Kubernetes **updates** the existing object rather than creating a new one.
* Focus is on confirming the update process, not on whether the new pod runs successfully (it may crash without Redis).

---

#### 2. Configuration File Update

1. Open the existing pod configuration file (`client-pod.yaml`).
2. Keep `kind` and `metadata.name` unchanged:

   ```yaml
   kind: Pod
   metadata:
     name: client-pod
   ```
3. Modify only the `image` field:

   ```yaml
   containers:
     - name: client
       image: stephengrider/multi-worker
   ```
4. Save the file.

---

#### 3. Applying the Update

Run the declarative update command:

```bash
kubectl apply -f client-pod.yaml
```

**Expected output:**

```
pod/client-pod configured
```

* The keyword **“configured”** indicates that the object was **updated**, not created.

---

#### 4. Verifying the Update

Check existing pods:

```bash
kubectl get pods
```

Output example:

```
NAME         READY   STATUS    RESTARTS   AGE
client-pod   1/1     Running   2          10m
```

* Only one pod exists (`client-pod`).
* Restart count increased due to the image update (container restarted).

---

#### 5. Inspecting Pod Details

To confirm that the pod now uses the new image:

```bash
kubectl describe pod client-pod
```

**Command syntax:**

```
kubectl describe <object_type> <object_name>
```

* You can omit the name to describe all objects of a type (e.g., all pods), but this produces large output.
* Typically, specify both type and name for precision.

**Output sections:**

* **Containers:** Lists container name and image.
  Example:

  ```
  Containers:
    Name:  client
    Image: stephengrider/multi-worker
  ```
* **Events:** Shows lifecycle messages (e.g., pulling image, restarts, crashes).

This confirms that the existing pod was updated **in place** to use the `multi-worker` image.

---

#### 6. Declarative Update Formula

Declarative updates in Kubernetes always follow this process:

1. Locate the **original configuration file**.
2. Modify configuration values as needed (e.g., image, labels, ports).
3. Keep `metadata.name` and `kind` unchanged.
4. Apply the file:

   ```bash
   kubectl apply -f <file>
   ```
5. Verify the update with:

   ```bash
   kubectl get <object_type>
   kubectl describe <object_type> <object_name>
   ```

If the **name** or **kind** changes, Kubernetes treats it as a **new object** creation instead of an update.

---

#### 7. Key Takeaways

* Declarative updates are consistent, repeatable, and preferred over imperative methods.
* `kubectl apply` is the standard command for applying configuration changes.
* The **object’s name and kind** uniquely identify it within the cluster.
* “configured” → existing object updated
* “created” → new object created

This workflow underpins the declarative model used across all Kubernetes object management.
