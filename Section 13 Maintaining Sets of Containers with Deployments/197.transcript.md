# **Tutor Notes — Verifying Deployment Access and Understanding Kubernetes Services**

## Objective

Confirm application access via the Kubernetes service and understand why services are required to connect to pods managed by deployments.

---

## Step 1: Accessing the Application

After deploying the client deployment, confirm the React application is accessible in a browser.

1. Retrieve the Minikube IP:

   ```bash
   minikube ip
   ```

   * This IP belongs to the Minikube VM (the Kubernetes node), **not localhost**.
   * Kubernetes pods and services run inside this VM with a separate network.

2. Access the service:

   * Open a browser and navigate to:

     ```
     http://<minikube-ip>:31515
     ```
   * `31515` is the hard-coded **NodePort** defined in `client-node-port.yaml`.
   * You should see the React frontend running from the pod created by the deployment.

---

## Step 2: Inspect Pod Details

To understand how Kubernetes manages pod networking, run:

```bash
kubectl get pods -o wide
```

This displays extended information including:

* **IP:** Internal cluster IP assigned to each pod.
* **NODE:** The node where the pod is running.

Example:

```
NAME                                  READY   STATUS    RESTARTS   AGE   IP            NODE
client-deployment-7d9c8f6d8b-l8x8f    1/1     Running   0          5m    172.17.0.6    minikube
```

* Each pod gets a **unique internal IP address** inside the cluster.
* These IPs are **not accessible** from the host system or browser directly—they exist only within the Kubernetes virtual network.

---

## Step 3: Why Direct Pod Access Is Not Reliable

* Pod IPs are **ephemeral** — they change whenever:

  * The pod is deleted and recreated.
  * The deployment updates or scales.
  * The node reassigns resources.

### Example

1. Initial pod IP: `172.17.0.1`

   * Accessible internally at `172.17.0.1:3000`
2. Pod deleted/recreated → new pod IP: `172.17.0.2`

   * Old IP is invalid.
   * You’d have to manually discover and update the new IP each time.

This makes direct connections to pods impractical, especially in production or scaled deployments.

---

## Step 4: Role of Kubernetes Services

A **Service** provides a **stable network endpoint** for accessing pods, even as pods are replaced or recreated.

### How It Works

* The service definition (e.g., `client-node-port.yaml`) contains a **selector**:

  ```yaml
  selector:
    component: web
  ```
* This selector continuously monitors all pods with the label `component=web`.
* The service automatically routes external traffic to any matching pods, regardless of IP changes.

### Benefits

* Ensures **continuous connectivity** to application pods.
* Decouples **client access** from **pod lifecycle**.
* Handles **load balancing** when multiple pod replicas exist.
* Provides **stable networking** for inter-pod communication within the cluster.

---

## Step 5: Summary

| Concept              | Description                                                                               |
| -------------------- | ----------------------------------------------------------------------------------------- |
| **Pod IPs**          | Internal-only, dynamically assigned, not persistent.                                      |
| **Services**         | Stable endpoints that forward traffic to pods using selectors.                            |
| **Selectors**        | Match labels on pods; enable automatic routing of requests.                               |
| **NodePort Service** | Exposes pods externally via a specific port (e.g., 31515).                                |
| **Use Case**         | Essential for accessing pods managed by deployments, especially when scaling or updating. |

---

### Verification

After confirming access through `http://<minikube-ip>:31515`, the deployment, service, and networking are functioning as expected.
