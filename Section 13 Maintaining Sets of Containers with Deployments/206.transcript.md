### Tutor Notes — Reasons to Access Docker Inside the Minikube Node

#### Recap

* Previously, we learned to **temporarily reconfigure the local Docker CLI** to connect to the **Docker server inside the Minikube VM** using:

  ```bash
  eval $(minikube docker-env)
  ```
* This reconfiguration applies **only to the current terminal session** and must be repeated every time a new terminal is opened.

---

### 1. Purpose of Accessing Docker Inside the Node

There are several practical reasons for directly interacting with the Docker server running inside Minikube’s Kubernetes node.

---

### 2. Reason 1 — Debugging Containers Using Docker Commands

Connecting to the Docker server inside the VM allows you to use **standard Docker debugging techniques** you learned earlier.

#### Steps:

1. Reconfigure the shell:

   ```bash
   eval $(minikube docker-env)
   ```
2. List containers:

   ```bash
   docker ps
   ```

   This shows all Kubernetes-related containers running in the VM.
3. Copy the container ID (e.g., for the `multi-client` container).
4. Retrieve logs:

   ```bash
   docker logs <container_id>
   ```

   * Displays container logs (if available).
5. Access a shell inside the container:

   ```bash
   docker exec -it <container_id> sh
   ```

   * Opens an interactive shell for direct inspection.

#### Equivalent via `kubectl`:

Most of these Docker debugging actions can also be performed using `kubectl`:

```bash
kubectl get pods
kubectl logs <pod_name>
kubectl exec -it <pod_name> sh
```

Both methods achieve similar results — choose based on your preference or context.

---

### 3. Reason 2 — Testing Kubernetes Self-Healing

You can verify Kubernetes’ **self-healing behavior** by manually deleting a container within the node.

Example:

```bash
docker ps
docker rm -f <container_id>
```

Kubernetes will automatically detect the missing container and **restart it** according to the pod specification.

This provides hands-on verification that Kubernetes correctly maintains desired state.

---

### 4. Reason 3 — Clearing Image Cache or Build Artifacts

If you encounter image caching issues (e.g., Kubernetes keeps reusing an outdated image), you can directly clear the cached Docker data inside the VM.

Command:

```bash
docker system prune -a
```

This removes:

* All stopped containers
* All unused networks
* All unused images
* Build cache

This helps when:

* Image updates aren’t reflected in new pods.
* Disk space in the node is running low.
* You want to reset the Docker environment.

---

### 5. Summary

| Use Case                       | Command(s)                                            | Purpose                                      |
| ------------------------------ | ----------------------------------------------------- | -------------------------------------------- |
| Inspect running containers     | `docker ps`, `docker logs`, `docker exec -it <id> sh` | Direct debugging access inside Minikube      |
| Verify Kubernetes self-healing | `docker rm -f <id>`                                   | Observe pod recreation by Kubernetes         |
| Clear cached images            | `docker system prune -a`                              | Reset Docker image cache in the node         |
| Equivalent Kubernetes tools    | `kubectl logs`, `kubectl exec`                        | Perform same operations using Kubernetes CLI |

---

**Key Takeaway:**
Accessing Docker inside the Minikube node provides direct visibility and control for debugging, troubleshooting, and validating Kubernetes behavior. However, these operations duplicate many `kubectl` capabilities — use them when deeper container-level inspection or manual control is required.
