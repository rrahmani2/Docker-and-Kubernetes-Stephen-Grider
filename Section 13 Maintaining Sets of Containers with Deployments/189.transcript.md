### Updating Existing Kubernetes Objects — Declarative Method (Tutor Notes)

#### 1. Objective

* Previous section: Compared **imperative vs declarative deployments**.
* Current section: Demonstrate **how to update an existing Kubernetes object** using the declarative approach.
* Goal: Update an existing **pod** to use the **`multi-worker`** image instead of the current **`multi-client`** image.

---

#### 2. Imperative Approach — Manual Update Steps

To update the pod imperatively, you would:

1. Run `kubectl get pods` to list all pods.
2. Identify the pod running the `multi-client` image.
3. Manually issue a command (e.g., `kubectl set image`) to change that pod’s image.

**Drawbacks:**

* Requires manually determining the current state.
* You must compute how to move from current → desired state.
* Involves multiple manual commands or API lookups.
* Infeasible for large or automated systems.

---

#### 3. Declarative Approach — Consistent Update Process

Updating an existing Kubernetes object declaratively always follows the **same process**:

1. Locate the **original configuration file** used to create the pod.
2. Modify the **`image`** field inside the configuration file:

   ```yaml
   # Before
   image: multi-client
   # After
   image: multi-worker
   ```
3. Apply the updated configuration using:

   ```bash
   kubectl apply -f pod-config.yaml
   ```
4. Kubernetes detects that the existing pod must be updated and modifies it accordingly — **no manual intervention** required.

---

#### 4. How Kubernetes Knows It’s an Update (Not a New Object)

When you run `kubectl apply`, the **Kube API Server (Master)** examines the configuration file and performs the following:

1. Reads the object’s **metadata** fields:

   * `name`
   * `kind` (object type)
2. Searches the cluster for an existing object matching both fields.
3. If a match is found → updates that existing object.
4. If no match exists → creates a new object.

Example:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: client-pod
```

* If a pod named **`client-pod`** already exists, the Master applies the new configuration to it.
* If you change the name (e.g., `client-pod-new`), the Master treats it as a **new object** and creates a fresh pod.

---

#### 5. Rules for Declarative Updates

* Always keep the **same `name`** and **same `kind`** when updating an existing object.
* Modify any other fields as needed (e.g., `image`, `labels`, `ports`, etc.).
* Apply the configuration again with `kubectl apply -f <file>`.
* The Master automatically reconciles changes with the existing object.

---

#### 6. Summary

* **Imperative approach:** Manual, state-dependent, error-prone.
* **Declarative approach:** Simple, repeatable, and consistent.
* Kubernetes identifies updates using the **combination of object name and kind**.
* Changing either name or kind results in **object creation**, not update.
* Declarative workflow ensures updates are handled automatically without manual state management.

Next step: Modify the original pod configuration file to replace the image from `multi-client` to `multi-worker` and observe Kubernetes update the existing pod rather than creating a new one.
