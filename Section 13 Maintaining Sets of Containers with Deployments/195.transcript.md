# **Tutor Notes — Breakdown of `client-deployment.yml` Configuration**

## Objective

Understand each section of the deployment configuration file and how Kubernetes interprets it when creating and managing pods.

---

## Key Structure Overview

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: client-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      component: web
  template:
    metadata:
      labels:
        component: web
    spec:
      containers:
        - name: client
          image: your-docker-id/multi-client:latest
          ports:
            - containerPort: 3000
```

---

## Breakdown

### 1. **apiVersion & kind**

* **`apiVersion: apps/v1`**
  Specifies the API group and version. Deployments belong to the `apps` group.
* **`kind: Deployment`**
  Declares the type of Kubernetes object being created.

These two fields tell Kubernetes that this file defines a **Deployment** object.

---

### 2. **metadata**

* **`name: client-deployment`**
  Assigns a unique name to this deployment resource.
  This is used by `kubectl` commands (e.g., `kubectl get deployment client-deployment`).

---

### 3. **spec**

Defines the desired behavior of the deployment.

#### a. **replicas**

* **`replicas: 1`**
  Specifies how many identical pods this deployment should maintain.

  * Each pod is created from the **template** below.
  * Increasing this number scales horizontally — for example, `replicas: 5` runs five identical pods.

#### b. **selector**

* **`matchLabels: component: web`**
  Defines which pods the deployment manages.

  * The **selector** must match the **labels** in the pod template exactly.
  * This link ensures the deployment can identify and control the pods it creates.

**Purpose of selector:**
When a deployment requests the master node to create pods, the Kubernetes controller on the master actually performs the creation.
To later manage or track those pods, the deployment relies on the selector to "find" pods with matching labels (in this case, `component: web`).

*Why both appear:*

* The selector (under `spec.selector.matchLabels`) identifies which pods belong to this deployment.
* The template’s labels (under `spec.template.metadata.labels`) define what labels new pods will have.
  They are defined twice because pods can have multiple labels, and deployments may only need to match on a subset.

---

### 4. **template**

Defines the configuration for each pod that the deployment creates and manages.

#### a. **metadata.labels**

* **`component: web`**
  Labels assigned to all pods created by this deployment.
  Must match the `selector.matchLabels` above.

#### b. **spec.containers**

* Defines the list of containers for each pod.

  * **`name: client`** — internal name of the container inside the pod.
  * **`image: your-docker-id/multi-client`** — specifies the Docker image to run.
  * **`ports.containerPort: 3000`** — exposes port 3000 from the container.

**Equivalent to the container definition in the earlier Pod manifest** — the deployment simply wraps that pod definition in a management layer.

---

## Summary of Behavior

* Deployment tells the Kubernetes master to create pods that match the **template**.
* The master schedules and runs the pods.
* The **selector** allows the deployment to track and manage those pods — restarting, updating, or replacing them if necessary.
* The **replicas** field controls scaling.
* Each created pod will run the same container image and expose the same port.

---

## Next Step

Apply the deployment file to the cluster:

```bash
kubectl apply -f client-deployment.yml
```

Then verify:

```bash
kubectl get deployments
kubectl get pods
```

This will create and run one pod managed by the deployment.
