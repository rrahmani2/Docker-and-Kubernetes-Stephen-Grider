# **Tutor Notes — Deploying and Verifying the Client Deployment**

## Objective

Delete the old standalone pod, deploy the new client deployment, and verify its state using `kubectl` commands.

---

## Step 1: Check Existing Pods

Before applying the new deployment, check for any existing pods created earlier.

```bash
kubectl get pods
```

If the original pod (created via `client-pod.yaml`) still exists, delete it to avoid confusion when verifying the deployment.

---

## Step 2: Delete the Existing Pod

To delete an existing object in Kubernetes, use the configuration file that was used to create it:

```bash
kubectl delete -f client-pod.yaml
```

### How it Works

* `kubectl` reads the YAML file and checks for:

  * **`kind`** — the type of resource (`Pod`)
  * **`metadata.name`** — the specific resource name (`client-pod`)
* It then finds and deletes the matching object in the cluster.

### Technical Note

* This deletion method is **imperative** — it’s a direct command to Kubernetes to modify cluster state.
* Kubernetes doesn’t have a declarative way to express "remove this resource" because declarative configs describe desired state, not deletions.
* Hence, `kubectl delete` remains the one area where imperative actions are necessary.

### Deletion Behavior

* The pod is given ~10 seconds to gracefully shut down (same as Docker containers).
* After the grace period, Kubernetes force-terminates the pod.
* Once completed:

  ```bash
  kubectl get pods
  ```

  should show **no running pods**.

---

## Step 3: Apply the Deployment

Now deploy the new configuration:

```bash
kubectl apply -f client-deployment.yaml
```

This creates a **Deployment** object that manages one or more identical pods.

---

## Step 4: Verify Pod Creation

Check active pods:

```bash
kubectl get pods
```

You should see:

* One running pod with a randomly generated name.
* The pod name will include the deployment name (e.g., `client-deployment-7d9c8f6d8b-xyz12`).

---

## Step 5: Verify Deployment Status

Check deployment details:

```bash
kubectl get deployments
```

### Output Columns Explained

| Column         | Meaning                                                            |
| -------------- | ------------------------------------------------------------------ |
| **DESIRED**    | Number of pods the deployment wants to maintain (from `replicas`). |
| **CURRENT**    | Number of currently running pods.                                  |
| **UP-TO-DATE** | Number of pods matching the latest deployment template.            |
| **AVAILABLE**  | Number of pods ready to serve requests (healthy state).            |

**Example:**

```
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
client-deployment  1/1     1            1           2m
```

* All values at `1` confirm the deployment successfully created one healthy pod.
* If the deployment is updated (e.g., image change), the `UP-TO-DATE` value drops to 0 until the new pods are created.

---

## Step 6: Next Step — Verify Application Accessibility

In the next step:

* Confirm the running pod is correctly using the `multi-client` image.
* Verify the React frontend is accessible in the browser through the appropriate service.

---

### Summary

* `kubectl delete -f <file>` removes a resource defined by the file (imperative operation).
* `kubectl apply -f <file>` creates or updates resources declaratively.
* Deployment manages pod replicas, updates, and health automatically.
* Status fields (`DESIRED`, `CURRENT`, `UP-TO-DATE`, `AVAILABLE`) indicate deployment health and scaling state.
