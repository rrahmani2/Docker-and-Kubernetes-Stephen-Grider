**Synopsis:**
This section explains how Docker’s **build cache mechanism** optimizes image creation by reusing previously built image layers. It demonstrates how Docker determines when to reuse or rebuild layers based on changes in the Dockerfile and how the order of instructions directly affects build performance.

---

**Rewritten Transcript:**

This lesson covers one final and critical concept in the Docker build process — **caching**. Caching is what makes Docker extremely efficient when creating or rebuilding images.

In the Dockerfile example, we initially had three instructions:

1. `FROM alpine`
2. `RUN apk add --update redis`
3. `CMD ["redis-server"]`

Each instruction in the Dockerfile creates a **new image layer**. The `FROM` instruction provides the Alpine base image. The `RUN` instruction creates a temporary container, installs Redis, and generates a new image layer from the updated file system. Finally, the `CMD` instruction defines the container’s startup command, producing the final image.

To demonstrate Docker’s caching behavior, a new instruction is added below the existing `RUN` line:

```dockerfile
RUN apk add --update gcc
```

This additional line installs GCC as a second dependency. When the image is rebuilt using `docker build .`, Docker compares the current build instructions against cached results from previous builds.

During this rebuild, Docker detects that the first two steps (`FROM alpine` and `RUN apk add --update redis`) have **not changed**. Since it already executed those steps earlier, Docker retrieves the cached layers instead of recreating them. The console output confirms this with the message **“Using cache.”**
Docker then executes the new instruction (`RUN apk add --update gcc`), since it’s new and has no cached equivalent. Once complete, Docker caches this new layer as well.

If the same `docker build .` command is run again **without modifying the Dockerfile**, Docker reuses all cached layers — Alpine, Redis, GCC, and CMD — and completes the build almost instantly.

Next, the Dockerfile is modified again by moving the GCC installation line **above** the Redis installation:

```dockerfile
RUN apk add --update gcc
RUN apk add --update redis
```

Even though both packages are still being installed, the **order of operations** has changed. Docker treats this as a new sequence of instructions. The cache for the Redis installation is invalidated because it depends on the previous step (which changed). As a result, Docker must rerun all steps **from the modified instruction downward**, rebuilding each affected layer.

This demonstrates Docker’s caching rule:

* If a line in the Dockerfile changes, all lines **after it** are rebuilt.
* Unchanged lines **before** the modification use cached results.

Therefore, when designing Dockerfiles, you should always place instructions that are **least likely to change** (like installing base dependencies) **higher up**, and instructions that change frequently (like copying code or configuration files) **lower down**. This ensures faster rebuilds and better cache efficiency.

---

**Summary:**

* Each Dockerfile instruction creates a new image layer.
* Docker caches completed layers locally for reuse.
* If a line in the Dockerfile changes, all subsequent steps must rebuild.
* The build cache significantly speeds up image creation.
* Keep frequently changing instructions at the bottom of the Dockerfile for optimal performance.
