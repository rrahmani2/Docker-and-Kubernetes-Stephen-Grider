**Synopsis:**
This section demonstrates the reverse process of what Dockerfiles do: creating a **custom image manually from a running container**. It shows how a container’s file system and configuration can be captured as a new image using `docker commit`. While educational, this approach is not recommended for regular workflows—Dockerfiles remain the standard method for reproducible image creation.

---

**Rewritten Transcript:**

There’s one last concept to show about building Docker images, which helps clarify the relationship between images and containers.

So far, we know that images are used to create containers. But as it turns out, the reverse is also possible: we can take a container, make changes to it, and generate a new image from it. Essentially, we can manually replicate what a Dockerfile does automatically.

To illustrate, we’ll emulate the Dockerfile process manually:

1. Start a new container from the Alpine image.
2. Install Redis inside the container.
3. Assign a default command and generate a new image.

In the terminal, we run:

```bash
docker run -it alpine sh
```

This starts a shell inside a temporary container. From there, we manually install Redis:

```bash
apk add --update redis
```

At this point, the container’s file system has been modified with Redis installed.

Next, in a separate terminal, we capture this container as a new image using `docker commit`. First, get the container ID with:

```bash
docker ps
```

Then commit the container, specifying the default command (`CMD`) for future runs:

```bash
docker commit -c 'CMD ["redis-server"]' <container_ID>
```

This produces a new image ID. You don’t need the full hash; Docker only requires the first few characters to identify it.

Finally, run a container from this newly created image:

```bash
docker run <new_image_ID>
```

The container starts, Redis is already installed, and the default command runs automatically.

This demonstrates that a container can be turned into an image, showing the fluid relationship between them. However, **using `docker commit` like this is discouraged** for real projects. Dockerfiles are preferred because they provide a reproducible, maintainable, and version-controlled process for building images.

This example is mainly educational, showing how containers and images can interact in both directions.
