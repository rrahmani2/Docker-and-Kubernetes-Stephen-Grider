### **Synopsis**

This lesson explains what actually happens during the **`docker build`** process, breaking down each step that occurs in the terminal when building an image from a Dockerfile. It details how Docker interprets each instruction, creates intermediate containers, captures file system snapshots, and ultimately produces the final image. Understanding this process gives a deeper insight into how Docker layers are formed and reused efficiently.

---

### **Understanding What Happens During `docker build`**

1. **Purpose of `docker build`**

   * The `docker build` command takes your **Dockerfile** and generates a **Docker image** from it.
   * Syntax:

     ```bash
     docker build .
     ```

     The `.` (dot) represents the **build context**, which is the set of files and directories in your current project folder. These files are available to Docker during the image build process.
   * When executed, the **Docker client** sends both the Dockerfile and build context to the **Docker server**, which performs the actual image build.

2. **Output Breakdown — Step-by-Step**
   When the build runs, the terminal output lists each instruction in the Dockerfile as a separate step:

   ```
   Step 1/3 : FROM alpine
   Step 2/3 : RUN apk add --update redis
   Step 3/3 : CMD ["redis-server"]
   ```

   Each step corresponds to one Dockerfile instruction and contributes a new **layer** to the final image.

---

### **Step 1: `FROM alpine`**

* Docker checks the **local cache** to see if the Alpine image already exists.
* If not found, it downloads it from **Docker Hub**, a public image registry.
* Once downloaded, Alpine becomes the **base layer** of the new image — a minimal Linux environment that future layers build upon.
* No intermediate container is created here because this step only defines the starting point.

---

### **Step 2: `RUN apk add --update redis`**

This is where the interesting behavior begins.

* **Temporary Container Creation**

  * Docker takes the image from the previous step (Alpine) and **creates a temporary container** from it.
  * In the build logs, you’ll see something like:

    ```
    Running in <container-id>
    ```

    This indicates a container was launched to execute the `RUN` command.

* **Executing the Command**

  * Inside this container, Docker executes `apk add --update redis`.
  * `apk` is Alpine’s **package manager**, used to install Redis and its dependencies.
  * This modifies the container’s file system — Redis binaries and configuration files are added.

* **Creating a New Image Layer**

  * Once the command finishes:

    1. Docker **stops the temporary container**.
    2. It **takes a snapshot** of its modified file system.
    3. It **saves** this snapshot as a new image layer.
  * You’ll see output like:

    ```
    Removing intermediate container <container-id>
    ```
  * This new layer now contains everything from the Alpine base image plus Redis installed.

---

### **Step 3: `CMD ["redis-server"]`**

* Docker takes the image produced in Step 2 (Alpine + Redis) and creates another temporary container.
* The `CMD` instruction **does not execute anything during the build**.
  Instead, it defines the **default startup command** for future containers based on this image.

  * In this case:

    ```bash
    redis-server
    ```

    will run automatically whenever a container is started from the final image.
* Docker then:

  1. Captures this container’s **file system snapshot** (which includes Redis).
  2. Saves it as the **final image**.
  3. Removes the intermediate container used for the CMD step.

---

### **Putting It All Together**

Each step in the build process works like this:

1. **Use** the image created from the previous step.
2. **Create** a temporary container from that image.
3. **Execute** the instruction (if applicable).
4. **Capture** a snapshot of the container’s file system changes.
5. **Save** the snapshot as a new image layer.
6. **Discard** the temporary container.

When the final instruction completes, the last image created (the one containing Redis and the CMD instruction) is tagged as the **final output** of the build process.

---

### **Summary**

* The `docker build` command sends your Dockerfile to the Docker server to create an image.
* Each instruction in the Dockerfile becomes a **layer**, built from the previous one.
* Docker creates **temporary containers** for instructions like `RUN`, executes commands, and captures the resulting file system changes as new image layers.
* The **final image** is the combination of all these layers, with a default command (`CMD`) defining what runs when the container starts.
* Understanding this layer-by-layer process is key to mastering Docker image creation and optimization.
