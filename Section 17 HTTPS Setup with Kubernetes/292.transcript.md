### Cert-Manager Integration — Technical Notes

**Objective:**
Configure Cert-Manager in Kubernetes to automatically obtain and manage TLS certificates from **Let’s Encrypt**.

---

#### 1. **Cert-Manager Core Concept**

* Installed as a **Deployment** that creates:

  * A **Pod** (Cert-Manager controller)
  * A **ServiceAccount**
  * **ClusterRole** and **ClusterRoleBinding** for permissions
* Function: Automates TLS certificate lifecycle—request, validation, issuance, renewal, and storage in Kubernetes secrets.

---

#### 2. **Required Kubernetes Objects**

##### a. **Issuer / ClusterIssuer**

* Defines **how** Cert-Manager should communicate with a Certificate Authority (CA) such as Let’s Encrypt.
* Specifies:

  * The CA endpoint (staging or production API)
  * Contact information (email)
  * ACME challenge type (HTTP-01 for Ingress-based validation)
* Types:

  * `Issuer` – namespace-scoped
  * `ClusterIssuer` – cluster-wide (recommended for shared Ingress usage)
* Example use case:

  * **Staging**: used for testing certificate issuance.
  * **Production**: used for real HTTPS deployment.

> ⚙️ *This project uses a single production `ClusterIssuer` with Let’s Encrypt’s production API.*

---

##### b. **Certificate**

* Defines **what** certificate to request.
* Contains:

  * The **domain(s)** (e.g., `example.com`, `www.example.com`)
  * Reference to the **Issuer/ClusterIssuer**
  * The **Kubernetes secret** name to store the certificate
* Cert-Manager automatically creates the secret and maintains it.

---

#### 3. **Certificate Lifecycle Flow**

1. **You create:**

   * A `ClusterIssuer` specifying Let’s Encrypt as the CA.
   * A `Certificate` object specifying the desired domain(s) and the secret name for storage.
2. **Cert-Manager detects** these resources automatically.
3. **Cert-Manager contacts** Let’s Encrypt using the Issuer configuration.
4. **Let’s Encrypt challenges** ownership (via HTTP-01 through Ingress).
5. **Cert-Manager responds** to the challenge by provisioning a temporary route.
6. **Let’s Encrypt validates** and issues the certificate.
7. **Cert-Manager stores** the issued certificate in a **Kubernetes Secret**.
8. **Ingress** is reconfigured to:

   * Serve HTTPS
   * Reference the secret containing the certificate.

---

#### 4. **Automation Notes**

* **Secrets are auto-created**; you do **not** run `kubectl create secret`.
* Once the `Certificate` is active, Cert-Manager:

  * Periodically checks certificate expiration.
  * Automatically renews certificates before expiry.

---

#### 5. **Next Steps**

* Create and apply a `ClusterIssuer` manifest (YAML) that connects to the Let’s Encrypt production API.
* Then, define the `Certificate` manifest referencing that issuer.
* Finally, update the **Ingress** to enable HTTPS using the generated secret.

---

**Summary:**
Cert-Manager coordinates between Kubernetes and Let’s Encrypt through two key custom resources — `Issuer` (defines how to get certificates) and `Certificate` (defines what certificates to obtain). After setup, Cert-Manager handles issuance, renewal, and secret storage automatically, requiring only an Ingress update to serve HTTPS traffic.
