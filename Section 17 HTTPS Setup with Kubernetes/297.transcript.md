### Deploying Cert-Manager Configuration — Technical Notes

**Objective:**
Deploy the **Issuer** and **Certificate** resources to Kubernetes so that Cert-Manager can automatically request and store a valid TLS certificate from Let’s Encrypt.

---

#### 1. **Deployment Order and Flow**

1. **Prerequisites already completed:**

   * Cert-Manager installed in the cluster (via Helm).
   * `ClusterIssuer` YAML created and applied.
   * `certificate.yaml` file created.

2. **Flow of operations:**

   * Apply the **Issuer** and **Certificate** manifests.
   * Cert-Manager detects these objects and starts the ACME (Let’s Encrypt) challenge process.
   * Once verification succeeds, a TLS **Secret** containing the certificate and key is automatically created.
   * Only **after** the secret is available do you modify your **Ingress** to reference it for HTTPS.

---

#### 2. **Key Steps (Manual Equivalent of the Demo)**

If you’re doing this outside CI/CD, here’s the sequence of commands:

```bash
# Deploy the issuer
kubectl apply -f k8s/issuer.yaml

# Deploy the certificate
kubectl apply -f k8s/certificate.yaml
```

Verify both resources are created:

```bash
kubectl get clusterissuer
kubectl get certificate
```

Check certificate status:

```bash
kubectl describe certificate <certificate-name>
```

Look for conditions like:

```
Type: Ready
Status: True
```

Once Cert-Manager completes the challenge, you’ll see a new secret:

```bash
kubectl get secrets
```

Example output:

```
NAME                   TYPE                DATA   AGE
k8smulti-com           kubernetes.io/tls   2      10m
```

That means the certificate (`tls.crt`) and private key (`tls.key`) are now stored and ready for use.

---

#### 3. **Automated Flow via Travis CI**

In this scenario:

* The developer commits and pushes changes directly to the **master** branch (bypassing the pull request flow).
* Travis CI detects the push and:

  1. Runs test suites.
  2. Executes deployment scripts (e.g., `kubectl apply -f k8s/`).
* As part of that deployment, Travis applies both:

  * `issuer.yaml`
  * `certificate.yaml`
* Kubernetes cluster updates:

  * Cert-Manager reads the new certificate request.
  * Begins ACME challenge with Let’s Encrypt.
  * Creates or updates a TLS secret upon success.

---

#### 4. **Expected Outcome in Kubernetes**

Within 10–15 minutes:

* Cert-Manager logs should show the ACME challenge process.
* The **Certificate** resource in the “Configuration” section of your cluster dashboard will appear as `Ready`.
* The secret (e.g., `k8smulti-com`) will be visible under **Configuration → Secrets**.

---

#### 5. **Next Step**

Once the certificate secret exists:

* Modify your existing **Ingress** configuration to use TLS:

  ```yaml
  tls:
    - hosts:
        - k8smulti.com
        - www.k8smulti.com
      secretName: k8smulti-com
  ```
* Apply the updated Ingress to enable HTTPS access.

---

**Summary:**
You’ve now deployed your **ClusterIssuer** and **Certificate** resources. Cert-Manager will automatically obtain the TLS certificate from Let’s Encrypt, store it as a secret in your cluster, and keep it renewed. Once that secret is ready, you’ll update your Ingress to use it for encrypted HTTPS traffic.
