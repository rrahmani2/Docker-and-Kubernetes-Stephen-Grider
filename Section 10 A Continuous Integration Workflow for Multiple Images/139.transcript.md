**Synopsis:**
This section prepares for creating the **production Dockerfile for the React client service**. The instructor reviews the earlier single-container deployment approach, contrasts it with the current multi-container setup, and explains the need to modify Nginx to serve the production React build on **port 3000** instead of port 80. The section also clarifies why two separate Nginx instances will be kept — one for routing and another for serving the frontend.

---

### Transcript Summary

#### Objective

Build a **production-ready Dockerfile** for the React frontend, adapted for a **multi-container architecture** that uses two Nginx servers.

---

### 1. Review of Previous Single-Container React Deployment

* Previously, in the **single-container setup**, the React app’s production build was done using a **multi-stage Dockerfile**:

  1. **Stage 1:** Based on Node — installed dependencies, ran `npm run build`.
  2. **Stage 2:** Based on Nginx — exposed port 80 and copied over the compiled static files.
* The Elastic Beanstalk instance served those assets directly on **port 80** via Nginx.

---

### 2. New Multi-Container Architecture

**Current setup:**

* Browser → **Main Nginx (Router)** → **Backend Services + React Client**
* The main Nginx server is responsible for routing requests to the correct backend.
* When requests for React assets are made, they’re **proxied to the React client container** running its own Nginx instance on **port 3000**.

**Production implication:**

* The client container will **serve React production assets** via Nginx, but **on port 3000**, not port 80.
* The outer (routing) Nginx will forward frontend requests to this inner Nginx.

---

### 3. Why Keep Two Nginx Instances?

**Yes, we could combine them — but we won’t.**

**Reasons:**

* In a real-world production environment, frontend files might not even be served by Nginx (e.g., via S3, CDN, or static file host).
* Keeping **separate responsibilities** (routing vs static serving) is more modular and mirrors actual distributed architectures.
* The router Nginx could remain constant even if the frontend delivery system changes later.

So, while technically possible to collapse them into a single Nginx, the course keeps both to reflect **production-grade design patterns**.

---

### 4. Key Modification for Production Client Dockerfile

* The Nginx configuration inside the React client container must:

  * **Listen on port 3000** (not 80).
  * Serve the built static React files from the `/usr/share/nginx/html` directory.

---

### Summary

* The **React client’s production Dockerfile** will be based on the earlier multi-stage build pattern.
* The **only major change**: configure Nginx to listen on **port 3000**.
* Maintaining **two Nginx containers** (router + static file server) ensures modularity and mirrors real-world architectures.

---

Next step: create the actual **production Dockerfile for the client service** with this port 3000 configuration.
