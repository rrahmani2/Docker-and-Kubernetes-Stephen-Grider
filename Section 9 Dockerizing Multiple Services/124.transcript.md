**Synopsis:**
In this section, the instructor begins creating the **Docker Compose configuration** for the **Complex application**, starting with **Postgres** and **Redis** services. The goal is to coordinate multiple containers — server, client, worker, databases — with correct ports, dependencies, and environment variables. This first step sets up the **Postgres** service to confirm that Compose works properly before adding the rest.

---

### Step-by-Step Summary

#### 1. **Goal**

* Start setting up a **`docker-compose.yml`** file.
* Define services for:

  * **Postgres** (database)
  * **Redis** (cache)
  * Later: Express **server**, React **client**, **worker**, and **Nginx**.
* Use this file to run all containers together with a single command.

---

#### 2. **Why Docker Compose?**

Managing several containers manually (`docker run ...` repeatedly) is tedious.
**Docker Compose** lets you:

* Define all containers in a single YAML file.
* Automatically create networks and environment variable links.
* Start everything with one command:

  ```bash
  docker-compose up
  ```

---

#### 3. **Create Docker Compose File**

Go to your root project directory (`complex/`):

```bash
cd complex
```

Create a new file:

```
docker-compose.yml
```

---

#### 4. **Base Structure**

Every Compose file starts with a version and a list of services:

```yaml
version: '3'
services:
```

---

#### 5. **Add Postgres Service**

The instructor starts with **Postgres** only.

```yaml
version: '3'
services:
  postgres:
    image: postgres:latest
```

Explanation:

* `postgres:` → the service name (how other containers will refer to it).
* `image: postgres:latest` → pulls the latest official Postgres image from Docker Hub.

No `build:` or `volumes:` are needed here yet — the base Postgres image handles setup automatically.

---

#### 6. **Choosing the Image**

* The instructor goes to **[hub.docker.com](https://hub.docker.com)** → searches for **Postgres**.
* Finds the **official Postgres repository**.
* Notes that the `latest` tag corresponds to a stable version (at the time, Postgres 10, but newer versions like 11 or 12 are fine).
* Uses `postgres:latest` in the Compose file.

---

#### 7. **Test Postgres Setup**

From inside the project root (`complex`):

```bash
docker-compose up
```

What happens:

* Docker pulls the Postgres image (if not cached).
* A new container starts and initializes a database instance.

Wait until you see:

```
database system is ready to accept connections
```

That confirms Postgres is running correctly inside Docker Compose.

---

#### 8. **Environment Variables (Preview)**

Later, the **server** and **worker** will need connection details for Redis and Postgres.

Those are defined via **environment variables** inside the Compose file — for example:

```yaml
environment:
  - POSTGRES_USER=postgres
  - POSTGRES_PASSWORD=postgres_password
  - POSTGRES_DB=postgres
```

But for now, they’re not yet added — that will come after Redis setup.

---

#### 9. **Reference for Postgres Configuration**

If you look further down the Postgres page on Docker Hub, you’ll find:

* Example commands to set a **Postgres password**.
* Additional environment variables you can pass (e.g., custom database name, username, etc.).
  These will be used in upcoming sections when configuring the Express server to connect.

---

### ✅ Summary

* Created `docker-compose.yml` in the root project.
* Added **Postgres** service using `postgres:latest`.
* Verified it runs correctly with `docker-compose up`.
* Next step: Add **Redis** to Compose and start linking services via environment variables.

---

**Next Section Preview:**
You’ll extend the Compose setup by adding the **Redis service**, then move on to the **server**, **worker**, and **client** containers — wiring everything together for a complete development environment.
