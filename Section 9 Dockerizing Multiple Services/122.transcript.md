**Synopsis:**
In this section, the instructor creates **development Dockerfiles** for the remaining two components — the **server** (Express API) and the **worker** (background processor). These are almost identical to the React client’s `Dockerfile.dev`, except they use **Nodemon** for automatic restarts during development. You’ll also see how to test-build and run both images.

---

### Step-by-Step Summary

#### 1. **Goal**

Add `Dockerfile.dev` files for:

* **server** → Express backend
* **worker** → background computation service

Both use **Node.js (Alpine)** as a base image and **Nodemon** for auto-reloading on source changes.

---

#### 2. **Setup: Server `Dockerfile.dev`**

Navigate to your **server directory**:

```bash
cd complex/server
```

Create a new file:

```
Dockerfile.dev
```

Add the following content:

```dockerfile
# Use lightweight Node base image
FROM node:alpine

# Set working directory
WORKDIR /app

# Copy dependency manifest
COPY package.json .

# Install dependencies
RUN npm install

# Copy project files
COPY . .

# Default command for development
CMD ["npm", "run", "dev"]
```

---

#### 3. **Why `npm run dev`?**

Both the **server** and **worker** use a `dev` script defined in their `package.json`:

```json
"scripts": {
  "dev": "nodemon"
}
```

`nodemon` automatically restarts the Node app when source files change — perfect for live development inside Docker.

---

#### 4. **Duplicate for Worker**

Navigate to the **worker directory**:

```bash
cd ../worker
```

Create another file:

```
Dockerfile.dev
```

Paste the exact same content:

```dockerfile
FROM node:alpine
WORKDIR /app
COPY package.json .
RUN npm install
COPY . .
CMD ["npm", "run", "dev"]
```

---

#### 5. **Build and Test the Server Container**

Go to the **server directory**:

```bash
cd ../server
```

Run:

```bash
docker build -f Dockerfile.dev -t server-dev .
```

What happens:

* Node Alpine image is pulled (if not cached).
* Dependencies are installed.
* Source files are copied.

You’ll get a final image ID when complete.

Test it:

```bash
docker run <image_id>
```

You may see:

```
Error: connect ECONNREFUSED 127.0.0.1:5432
```

That’s expected — it’s complaining that **Postgres** isn’t running yet.
You can ignore this for now and stop the container with **Ctrl+C**.

---

#### 6. **Build and Test the Worker Container**

Now switch to the **worker directory**:

```bash
cd ../worker
```

Run:

```bash
docker build -f Dockerfile.dev -t worker-dev .
```

Then:

```bash
docker run <image_id>
```

You’ll see Nodemon start successfully with **no connection errors**, since the worker doesn’t directly require Postgres at this point.

Stop it with **Ctrl+C**.

---

#### 7. **Final Project Structure**

After this step, your `complex` directory should look like:

```
complex/
├── client/
│   └── Dockerfile.dev
├── server/
│   └── Dockerfile.dev
└── worker/
    └── Dockerfile.dev
```

---

### ✅ Summary

* Created **development Dockerfiles** for `server` and `worker`.
* Used **Nodemon** (`npm run dev`) for auto-restarts on code changes.
* Successfully built and tested both images.
* Postgres-related “connection refused” error for server is expected — databases will be added later.

Next section: You’ll set up **Docker Compose** to run all three services (client, server, worker) together.
