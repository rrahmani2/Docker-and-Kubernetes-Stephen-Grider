### ðŸ§© **Synopsis: Purpose of Nginx in the Development Docker Compose Setup**

In this section, the instructor explains **why Nginx is needed in the development environment**, even though it was previously used only in production. The main goal is to use Nginx as a **reverse proxy** that intelligently routes browser requests between the **React client** and **Express server** within the Docker Compose network. This setup avoids dealing with multiple ports and allows the frontend to use a simple `/api` prefix for backend requests.

---

### âš™ï¸ **Key Concepts and Architecture**

1. **Current Issue:**

   * The Docker Compose file has **no ports defined**, so none of the services (client, server, etc.) are exposed to the outside world.
   * The browser cannot communicate directly with any container.

2. **Development Architecture Recap:**

   ```
   Browser
       |
       â†“
   Nginx (reverse proxy)
       â”œâ”€â”€> React server (for HTML/JS)
       â””â”€â”€> Express server (for API routes)
   ```

3. **Browser Request Behavior:**

   * The browser will request:

     * **Static files** like `index.html` and `main.js` (handled by React).
     * **API routes** (e.g., `/api/values/all`) to interact with the backend (handled by Express).

4. **Routing Problem:**

   * **React frontend** expects to hit `/api/...` routes.
   * **Express backend** actually handles routes like `/values`, `/values/all`, `/values/current` (without `/api`).
   * Currently, thereâ€™s no mechanism to direct `/api` requests to the correct service.

5. **Nginx Solution:**

   * Introduce an **Nginx container** as a new service in `docker-compose.yml`.
   * Its job is to inspect incoming requests and **route based on the request path**:

     * Requests containing `/api` â†’ forwarded to **Express server**.
     * All other requests (HTML/JS) â†’ forwarded to **React server**.
   * Nginx will **strip the `/api` prefix** before passing the request to Express.

     * Example: `/api/values/all` â†’ `/values/all`.

6. **Why Not Expose Multiple Ports?**

   * Managing separate ports for client and server (e.g., `:3000` and `:5000`) is messy.
   * In production, ports can change frequently, making it unreliable.
   * Using `/api` as a **constant route prefix** simplifies client-side configuration â€” all requests go to a single exposed endpoint, and Nginx handles internal routing.

7. **Behavior Summary:**

   * Client requests â†’ `/api/...` for backend calls.
   * Nginx proxies:

     * `/api/*` â†’ Express container.
     * everything else â†’ React container.
   * `/api` is removed before the request reaches Express.

---

### ðŸ§  **Key Takeaways**

* **Nginx acts as a reverse proxy** in development, centralizing all traffic through a single entry point.
* It handles **intelligent routing** between frontend and backend services inside Docker.
* The `/api` prefix is a **stable and environment-agnostic** way to distinguish backend routes.
* The upcoming step will involve **building and configuring the Nginx container** to perform this routing automatically.
