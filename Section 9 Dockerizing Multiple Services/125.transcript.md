**Synopsis:**
This section extends the `docker-compose.yml` file by adding **Redis** and the **Express server** service.

* Redis is added quickly using its official image (`redis:latest`).
* The server (Express API) service gets a **build configuration**, **context**, and **volumes**, ensuring live code changes reflect immediately inside the container — no need to rebuild on every modification.
  Next, environment variables for the server will be added.

---

### Step-by-Step Breakdown

#### 1. **Recap**

Previously, we:

* Created `docker-compose.yml`
* Added **Postgres** as a service.

Now we’ll:

* Add **Redis**.
* Add the **server** service with proper build and volume configuration.

---

#### 2. **Add Redis Service**

The Redis setup is minimal — no configuration needed yet.

```yaml
version: '3'
services:
  postgres:
    image: postgres:latest

  redis:
    image: redis:latest
```

Explanation:

* `redis:` — service name (used by other containers for internal DNS).
* `image: redis:latest` — uses the official Redis image.
* No extra environment or volume setup required (defaults are fine).

**Note:**
Even if the Redis image’s `latest` tag changes to version 5 or 6 in the future, the app will work fine.

---

#### 3. **Add the Server Service**

Next, define the **Express server** container that depends on these databases.

```yaml
  server:
    build:
      dockerfile: Dockerfile.dev
      context: ./server
    volumes:
      - /app/node_modules
      - ./server:/app
```

##### **Explanation:**

**→ `build:` block**

* `dockerfile: Dockerfile.dev`

  * Tells Docker Compose which file to use when building the image.
  * Only the name, *not the path*, is given because the `context` defines where to look.
* `context: ./server`

  * Points Docker to the directory where the server’s source code and `Dockerfile.dev` live.
  * Compose will look inside this directory to find the Dockerfile and application files.

**→ `volumes:` block**

* `- /app/node_modules`

  * Prevents the host’s filesystem from overwriting the container’s installed node modules.
* `- ./server:/app`

  * Maps the host’s `server` directory to the container’s `/app` directory.
  * Enables **live code reloading** — any local file change syncs instantly into the container.

This is critical for a fast **development workflow** — no need to rebuild the image every time you change code.

---

#### 4. **Resulting Compose File (So Far)**

Your `docker-compose.yml` should now look like this:

```yaml
version: '3'
services:
  postgres:
    image: postgres:latest

  redis:
    image: redis:latest

  server:
    build:
      dockerfile: Dockerfile.dev
      context: ./server
    volumes:
      - /app/node_modules
      - ./server:/app
```

---

#### 5. **Next Steps**

In the next section, you’ll:

* Add **environment variables** for the `server` service to connect to **Postgres** and **Redis**.
* These will include variables like:

  ```yaml
  environment:
    - REDIS_HOST=redis
    - REDIS_PORT=6379
    - PGUSER=postgres
    - PGHOST=postgres
    - PGPASSWORD=postgres_password
    - PGDATABASE=postgres
    - PGPORT=5432
  ```

That configuration will complete the backend container setup so the server can actually communicate with both databases.

---

**✅ Summary**

* Added **Redis** service using the official image.
* Added **server** service with:

  * `build` context (`./server`)
  * `Dockerfile.dev`
  * Live-sync volumes.
* Prepared groundwork for adding **environment variables** in the next lesson.
