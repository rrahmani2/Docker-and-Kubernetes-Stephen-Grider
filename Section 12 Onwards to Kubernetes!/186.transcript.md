# **Tutor Notes: Deploying and Accessing Kubernetes Objects**

---

## **1. Applying Configuration Files**

* **Command used:**

  ```bash
  kubectl apply -f <file-name>.yaml
  ```
* **Purpose:** Updates or creates Kubernetes objects defined in the YAML configuration files.

  * `kubectl`: CLI tool to interact with the Kubernetes cluster.
  * `apply`: Changes or syncs the cluster state based on the configuration file.
  * `-f`: Indicates the file path to the configuration.

### **Example**

```bash
kubectl apply -f client-pod.yaml
kubectl apply -f client-node-port.yaml
```

* **Output message:**

  * Shows `"configured"`, which means the cluster has accepted and applied the YAML configuration.
  * This doesn’t confirm if the object is running successfully — a status check is needed.

---

## **2. Checking Object Status**

### **a. Checking Pod Status**

```bash
kubectl get pods
```

* **Purpose:** Lists all Pods and their current state.

| Field        | Meaning                                                            |
| ------------ | ------------------------------------------------------------------ |
| **NAME**     | Pod name (e.g., `client-pod`)                                      |
| **READY**    | Number of running containers vs. desired containers (`1/1`)        |
| **STATUS**   | Current Pod state (`Running`, `Pending`, `CrashLoopBackOff`, etc.) |
| **RESTARTS** | Number of times containers have restarted                          |
| **AGE**      | Time since the Pod was created                                     |

* Example Output:

  ```
  NAME          READY   STATUS    RESTARTS   AGE
  client-pod    1/1     Running   0          1m
  ```

* `1/1` means one desired container and one running container.

* If a container fails, Kubernetes automatically restarts it, and the **RESTARTS** count increments.

---

### **b. Checking Service Status**

```bash
kubectl get services
```

* **Purpose:** Lists all active Services in the cluster.

* Example Output:

  ```
  NAME              TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)           AGE
  kubernetes        ClusterIP   10.96.0.1      <none>        443/TCP           1h
  client-node-port  NodePort    10.99.83.217   <none>        80:31515/TCP      2m
  ```

* **Explanation:**

  * The default **`kubernetes`** Service (type `ClusterIP`) is internal — ignore it.
  * The **`client-node-port`** Service is user-defined.

| Field           | Meaning                                                      |
| --------------- | ------------------------------------------------------------ |
| **TYPE**        | Service type (NodePort, ClusterIP, etc.)                     |
| **CLUSTER-IP**  | Internal IP accessible within the cluster                    |
| **EXTERNAL-IP** | Public IP (if exposed; empty for NodePort in local clusters) |
| **PORT(S)**     | `port:nodePort` format (e.g., `80:31515/TCP`)                |
| **AGE**         | Service uptime                                               |

* **Important:**

  * Only `port` and `nodePort` are displayed — `targetPort` is intentionally hidden, as it’s internal and usually unnecessary for status checks.

---

## **3. Accessing the Application**

### **a. Expected (Incorrect) Attempt**

You might expect to access it via:

```
http://localhost:<nodePort>
```

Example:

```
http://localhost:31515
```

This will **not work**.

### **b. Correct Method Using Minikube IP**

Minikube runs a **virtual machine (node)** that hosts the cluster.
Localhost does **not** map to the Minikube node.

#### **Find Node IP**

```bash
minikube ip
```

* Output example:

  ```
  192.168.49.2
  ```

* Use this IP to access your NodePort Service:

  ```
  http://192.168.49.2:31515
  ```

> ⚠️ Never use `localhost` for accessing Minikube workloads.
> Always use the IP returned by `minikube ip`.

---

## **4. What Happens Internally**

1. Browser request → Minikube VM IP (`minikube ip`) on port `31515`.
2. `kube-proxy` on the node routes traffic:

   * **NodePort (31515)** → **Service port (80)** → **Pod container port (3000)**.
3. The container (running NGINX) serves the application page.

---

## **5. Expected Result**

* Accessing `http://<minikube-ip>:<nodePort>` displays the web application.
* Errors related to backend API calls (e.g., Express API) are expected until backend services are deployed.

---

## **6. Key Concepts Summary**

| Command                           | Purpose                                  |
| --------------------------------- | ---------------------------------------- |
| `kubectl apply -f <file>`         | Create or update objects defined in YAML |
| `kubectl get pods`                | Show status of all Pods                  |
| `kubectl get services`            | Show status of all Services              |
| `minikube ip`                     | Get IP of the node VM                    |
| `http://<minikube-ip>:<nodePort>` | Access the running Service in a browser  |

| Term                   | Explanation                                         |
| ---------------------- | --------------------------------------------------- |
| **apply**              | Synchronizes configuration files with cluster state |
| **Pod**                | Runs one or more containers                         |
| **Service (NodePort)** | Exposes Pods externally through a specific port     |
| **port**               | Cluster-internal Service port                       |
| **targetPort**         | Container port in the Pod                           |
| **nodePort**           | External port on node (browser access)              |
| **localhost**          | Not applicable for Minikube — use Minikube IP       |

---

## **7. Conclusion**

* Both **Pod** and **Service** objects are deployed and running in the local Minikube cluster.
* Kubernetes requires explicit Service configuration for any network access — unlike Docker Compose or Elastic Beanstalk, which manage this automatically.
* Use `kubectl` commands to verify and inspect object states.
* Always use `minikube ip` to access applications running inside the Kubernetes VM.
