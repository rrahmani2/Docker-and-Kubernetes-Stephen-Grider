# **Tutor Notes: Kubernetes Services and Metadata**

---

## **1. Metadata in Pod Configuration**

* The `metadata` section in the Pod YAML provides identifying information for the object.
* **`name`**: Assigns a name to the Pod (e.g., `client-pod`).

  * Used primarily for **logging and cluster management**.
  * Displayed in `kubectl` outputs.
* **`labels`**: Defines key-value pairs used to **associate Pods with other objects**, such as Services.

  * Example: `component: web`
  * This label is how a Service identifies which Pods it routes traffic to.

---

## **2. Introduction to Kubernetes Services**

* A **Service** is a second major Kubernetes object type, primarily used for **networking**.
* Purpose: **Expose Pods** to other components or to the external world.
* File reference: `client-node-port.yml`
* Example definition:

  ```yaml
  apiVersion: v1
  kind: Service
  metadata:
    name: client-node-port
  spec:
    type: NodePort
  ```
* Services are critical for defining **how network traffic reaches Pods**.

---

## **3. Service Types**

Kubernetes defines **four** core Service subtypes:

| Service Type     | Description                                                    | Usage                  |
| ---------------- | -------------------------------------------------------------- | ---------------------- |
| **ClusterIP**    | Default type; exposes Pods only within the cluster.            | Internal communication |
| **NodePort**     | Exposes Pods to the external world via a port on each node.    | Development/testing    |
| **LoadBalancer** | Integrates with external cloud load balancers (e.g., AWS ELB). | Production             |
| **Ingress**      | Provides advanced routing (e.g., host/path-based).             | Production             |

> **Note:**
> NodePort is typically used **only for development**, not for production, except in rare scenarios.

---

## **4. NodePort Service Overview**

* The **NodePort Service** allows external traffic to access a container running inside a Pod.
* When created:

  * It opens a port (e.g., `31515`) on the **Kubernetes node (VM)**.
  * Routes requests through **kube-proxy** to the correct Pod and container.

### **Diagram Summary**

* **Node (VM)**: Created by Minikube, hosts the Pod.
* **kube-proxy**: Runs on each node and manages traffic routing to Services and Pods.
* Incoming requests → kube-proxy → NodePort Service → Target Pod (e.g., `client-pod`).

---

## **5. Label and Selector Relationship**

Kubernetes uses a **Label Selector System** to link Services with target Pods.

* **In Pod file (`client-pod.yml`):**

  ```yaml
  metadata:
    labels:
      component: web
  ```

* **In Service file (`client-node-port.yml`):**

  ```yaml
  spec:
    selector:
      component: web
  ```

* Mechanism:

  * The Service scans for any Pod in the cluster with a label matching its `selector`.
  * All matching Pods are automatically added as Service endpoints.
  * Example:

    * Selector: `component: web`
    * Pod Label: `component: web`
    * ⇒ Service forwards traffic to that Pod.

> The label key and value are **arbitrary** — both must match exactly.
> Example alternative: `tier: frontend` (must appear in both Service selector and Pod labels).

---

## **6. Service Ports Explained**

Service definition includes **three key port fields**:

| Field          | Purpose                                                                            | Example |
| -------------- | ---------------------------------------------------------------------------------- | ------- |
| **port**       | Internal port exposed by the Service, accessible to other Pods within the cluster. | `80`    |
| **targetPort** | Port on the container inside the Pod where traffic is sent.                        | `3000`  |
| **nodePort**   | Port on the node that exposes the Service externally.                              | `31515` |

### **Example:**

```yaml
ports:
  - port: 80
    targetPort: 3000
    nodePort: 31515
```

### **Behavior:**

* **port (80):** Used by other Pods for internal communication (not relevant for this setup).
* **targetPort (3000):** Forwards traffic inside the Pod to the container port.
  Matches the `containerPort: 3000` defined in the Pod.
* **nodePort (31515):** Exposes the Service externally at:

  ```
  http://<Node_IP>:31515
  ```

  Used to access the container via browser.

> NodePort range: **30000–32767**.
> If omitted, Kubernetes auto-assigns a random port in this range.

---

## **7. Why NodePort Is Not for Production**

* Uses high, non-standard port numbers (e.g., `:31515`) unsuitable for public web access.
* No built-in load balancing or DNS integration.
* Better production options: **LoadBalancer** or **Ingress**.

---

## **8. Summary**

| Concept           | Description                                            |
| ----------------- | ------------------------------------------------------ |
| `metadata.name`   | Logical name of the Pod or Service (used in logging).  |
| `metadata.labels` | Key-value pair used for grouping and selection.        |
| Service           | Kubernetes object that manages network access to Pods. |
| Service Types     | ClusterIP, NodePort, LoadBalancer, Ingress.            |
| Selector          | Matches Services to Pods via shared labels.            |
| port              | Internal Service port (cluster-only).                  |
| targetPort        | Pod/container port receiving the traffic.              |
| nodePort          | External port on node (developer browser access).      |
| NodePort range    | 30000–32767 (auto-assigned if not set).                |

---

## **9. Next Step**

Apply both configuration files to the cluster using `kubectl`:

```bash
kubectl apply -f client-pod.yml
kubectl apply -f client-node-port.yml
```

This creates:

* A **Pod** running the container.
* A **NodePort Service** exposing it externally.
