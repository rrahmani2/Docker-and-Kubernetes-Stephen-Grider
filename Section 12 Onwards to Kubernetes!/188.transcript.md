### Kubernetes Deployment Concepts — Declarative vs Imperative (Tutor Notes)

#### 1. Core Recap

* Kubernetes is fundamentally a **system for deploying containerized applications**.
* All components — pods, services, objects — exist to support container management and orchestration.

#### 2. Key Components

* **Node:** A physical or virtual machine running containers or Kubernetes objects.

  * In Minikube, a single VM represents the node.
* **Master:**

  * Manages the cluster and nodes.
  * Runs control-plane programs (e.g., `kube-apiserver`).
  * Decides where each container (pod) is scheduled.
* **Docker Hub:**

  * Kubernetes **pulls images** from Docker Hub; it does **not** build images itself.

---

#### 3. Deployment and Desired State

* When a deployment file is applied using `kubectl apply -f <file>.yaml`,
  the **master updates its desired state** — the list of responsibilities it must fulfill.
* Example:

  ```yaml
  replicas: 4
  image: multi-worker
  ```

  The master interprets this as:

  > “Run four replicas of the `multi-worker` image.”
* Developers **define the desired state**, not individual container creation commands.

  * Kubernetes handles how and where to achieve that state.
* The **master continuously ensures** the actual cluster state matches the declared desired state.

  * If a container dies, it is automatically recreated to restore equilibrium.

---

#### 4. Imperative vs Declarative Deployment

| Approach        | Description                                                                                       | Example Behavior                                                |
| --------------- | ------------------------------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **Imperative**  | You explicitly define *how* to reach a goal by issuing direct commands.                           | “Create this container”, “Delete that pod”, “Upgrade this one”. |
| **Declarative** | You define *what* you want the final system state to be. Kubernetes figures out how to get there. | “Run 4 containers using image version 1.23”.                    |

---

#### 5. Example: Imperative Deployment

* Suppose you want **3 containers** running.
* You open a dashboard and see **4 containers** active.
* You manually issue a command to remove one container.
* Process involves:

  1. Identifying current state.
  2. Determining desired state (3 containers).
  3. Calculating migration actions (remove one container).

**Problems:**

* Manual computation of state differences.
* High risk of inconsistency in large clusters.
* Tedious for updates and scaling.

---

#### 6. Example: Updating via Declarative Deployment

* Desired: upgrade all `multi-worker` containers to version `1.23`.
* Process:

  1. Edit deployment YAML:

     ```yaml
     image: multi-worker:1.23
     ```
  2. Apply the configuration:

     ```bash
     kubectl apply -f deployment.yaml
     ```
  3. Master updates desired state and reconciles it:

     * Detects pods not running `1.23`.
     * Terminates outdated pods.
     * Creates new pods using the updated image.
  4. Cluster automatically transitions to the new state.

**Result:**
No manual node inspection or individual pod management required.

---

#### 7. Why Declarative Is Preferred

* Declarative configuration:

  * Scalable, repeatable, and version-controlled.
  * Ideal for production environments.
* Imperative commands:

  * Temporary, error-prone, and lack persistent documentation.
* Kubernetes supports both, but production practice always favors **declarative YAML-based configuration**.

---

#### 8. Key Takeaways

* Developers **update configuration files** to express desired state.
* Kubernetes **continuously reconciles** actual cluster state with desired configuration.
* Avoid imperative-style blog posts recommending direct `kubectl` actions like “add pod” or “update pod.”
* Real-world workflow:

  1. Edit config →
  2. Apply via `kubectl apply -f` →
  3. Kubernetes reconciles state.
* Repeat this cycle for all deployments, scaling, and updates — in both development and production environments.
