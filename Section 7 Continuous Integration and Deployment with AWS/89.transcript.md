Here’s the complete picture for your **`.travis.yml`** setup so far, based on what you just described:

---

### **Travis CI Workflow**

1. **Prerequisites**

   * `sudo: required` → Needed for Docker commands.
   * `services: docker` → Installs Docker in the Travis build environment.

2. **Build the Docker Image**

   * In the `before_install` section, build your development Docker image and tag it:

     ```yaml
     before_install:
       - docker build -f Dockerfile.dev -t stephengrider/docker-react .
     ```

3. **Run Tests**

   * In the `script` section, start a container from that image and run the test suite:

     ```yaml
     script:
       - docker run stephengrider/docker-react npm run test -- --coverage
     ```

   **Notes:**

   * `-- --coverage` ensures that the test runner exits automatically after the first run. Without it, `npm test` hangs in watch mode.
   * Travis CI interprets a **non-zero exit code** as a failure, so it automatically detects test failures.

---

### **Full Example `.travis.yml`**

```yaml
sudo: required
services:
  - docker

before_install:
  - docker build -f Dockerfile.dev -t stephengrider/docker-react .

script:
  - docker run stephengrider/docker-react npm run test -- --coverage
```

---

With this setup:

* Any commit pushed to GitHub triggers Travis CI.
* Travis builds your dev Docker image.
* Travis runs the tests in that container.
* Travis reports success/failure based on the test results.

---

If you want, I can also show a **slightly improved version** that prevents leftover containers from stacking up and makes the Travis output cleaner. It’s a small tweak but makes the CI workflow more robust. Do you want me to show that?
