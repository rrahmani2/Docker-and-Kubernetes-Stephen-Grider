Here’s the key explanation of the issue and fix you just went through:

---

### **Problem:** Application not reachable after Elastic Beanstalk deploy

* Your Docker container runs the web server inside the container.
* On your local machine, you usually do `docker run -p HOST_PORT:CONTAINER_PORT …` to map ports.
* Elastic Beanstalk doesn’t automatically know which port to map.
* As a result, even though the deployment succeeds, the URL doesn’t load because no port is exposed for incoming traffic.

---

### **Solution:** Use the `EXPOSE` instruction in the Dockerfile

1. Open your **production Dockerfile** (`Dockerfile.prod` or similar).
2. Add this line **after the `FROM nginx` line** (or your base image):

```dockerfile
EXPOSE 80
```

* This tells Elastic Beanstalk which port the container listens on.
* Elastic Beanstalk automatically maps incoming traffic to that port.
* On local machines, `EXPOSE` doesn’t do anything by itself—it’s informational—but on Elastic Beanstalk, it controls port mapping.

---

### **Next steps**

1. Save the Dockerfile after adding `EXPOSE 80`.
2. Commit and push the change:

```bash
git add Dockerfile.prod
git commit -m "Added EXPOSE 80 for Elastic Beanstalk"
git push origin master
```

3. Travis CI will pick up the new commit, run the build/tests, and then deploy the updated container.
4. After deployment completes, refresh the Elastic Beanstalk URL—the app should now load correctly.

---

If you want, I can also explain **why Elastic Beanstalk behaves differently from `docker run -p`** and why `EXPOSE` is critical for cloud deployments. It’s a subtle but important point for production Docker setups. Do you want me to go over that?
