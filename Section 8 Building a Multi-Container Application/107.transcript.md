**Synopsis: Backend Architecture of the Multi-Container Fibonacci Application**

---

### **1. Purpose of This Section**

* To explain the **backend architecture** for the multi-container Fibonacci application.
* The focus is on how multiple Dockerized components (Nginx, Express, Redis, Postgres, Worker) interact to form one cohesive system.
* It’s intentionally **over-engineered** to demonstrate real-world multi-service integration and communication.

---

### **2. Overview of the Backend Architecture**

When a user visits the app through a browser, the request first hits an **Nginx web server**.
Nginx acts as a **reverse proxy and router**, deciding where to forward each request.

* **Frontend requests** (HTML, CSS, JS) → Routed to the **React server**.
* **API requests** (submit index, get results) → Routed to the **Express server**.

So, Nginx becomes the single entry point that connects the frontend and backend seamlessly.

---

### **3. Data Flow and Services**

The backend uses **three main components** to manage data and computation:

1. **Postgres Database (Persistent Storage)**

   * Stores all **submitted indices** (values that users have entered).
   * Acts as the **permanent record** of what the app has seen.

2. **Redis (Temporary Storage)**

   * Holds **calculated Fibonacci results**.
   * Used for **fast, in-memory access**.
   * Acts as a message queue between the Express server and the worker process.

3. **Worker Service (Node.js Process)**

   * Constantly monitors Redis for new indices.
   * When a new index appears:

     1. Fetches it from Redis.
     2. Calculates the Fibonacci value.
     3. Stores the result back in Redis.
   * Offloads heavy computation from the Express server.

---

### **4. Step-by-Step Request Flow**

1. User submits a number (e.g., `7`) through the React app.
2. React sends an **AJAX request** to the **Express API server**.
3. Express:

   * Saves the submitted index (`7`) into **Postgres**.
   * Pushes the same index into **Redis**.
4. Redis notifies the **Worker** that new work has arrived.
5. Worker:

   * Retrieves the index (`7`) from Redis.
   * Computes Fibonacci(7) = `21`.
   * Stores the result back in Redis.
6. React app periodically fetches results from the Express API,
   which retrieves them from Redis and displays:
   **“For index 7, I calculated 21.”**

---

### **5. Why This Design?**

* Purely for **learning purposes** — a way to:

  * Demonstrate how **multiple containers communicate**.
  * Show integration between **databases, caches, workers, and reverse proxies**.
  * Illustrate how **backend processing** and **frontend rendering** can be separated.

Even though a Fibonacci calculator doesn’t need this much complexity, the architecture mimics **real production-grade microservice deployments**.

---

### **6. Next Step**

In the next section, you’ll start **building the application from scratch**, defining containers and wiring up this backend flow using **Docker and Docker Compose**.
