**Synopsis: Transition from Single to Multi-Container Deployment**

---

### **1. Terminate the Previous Application**

* Before moving on, **terminate your Elastic Beanstalk application** from the previous section.
* This avoids unnecessary AWS billing.
* If you don’t mind minor charges, you can leave it running; otherwise, delete it now.

---

### **2. Review of Single-Container Deployment Issues**

**a. Application Simplicity**

* The deployed app was just a **React frontend served by Nginx** — no backend logic, APIs, or databases.
* This setup didn’t challenge Docker’s orchestration or service-linking capabilities.

**b. Inefficient Image Builds**

* The Docker image was built **twice**:

  1. During testing on **Travis CI**.
  2. Again during deployment to **Elastic Beanstalk**.
* This duplication is inefficient.
* Worse, it forced the **production web server** to rebuild the image — not an ideal responsibility for a live instance.

**c. Lack of Real-World Complexity**

* The single-container app didn’t use:

  * Any **databases** (PostgreSQL, MongoDB, etc.)
  * Any **API layer**
  * Any **caching mechanism** (like Redis)
* To truly master containerized architectures, you need to work with **interdependent services**.

---

### **3. Next Step**

* You’ll now move to a **multi-container application**:

  * Multiple services communicating together.
  * Managed with **Docker Compose**.
  * Eventually deployed to **AWS Elastic Beanstalk** as a multi-container environment.

---

**Coming up next:**
Overview of the new multi-container application — what components it includes and how they interact.
