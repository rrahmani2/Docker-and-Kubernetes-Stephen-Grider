### Verifying Ingress-NGINX Setup (Local Testing)

#### 1. Objective

Confirm that the Ingress-NGINX configuration successfully routes external traffic into the Kubernetes cluster and directs it to the appropriate services.

---

#### 2. Retrieve Minikube IP

Run the following command to get the external IP of the Minikube virtual machine:

```bash
minikube ip
```

* Example output: `192.168.49.2`
* Copy the IP and open it in your browser.

> **Note:** You do **not** need to specify a port (`:3000` or `:5000`) since Ingress-NGINX listens automatically on **ports 80 (HTTP)** and **443 (HTTPS)**.

---

#### 3. HTTPS Warning (Expected Behavior)

* On first access, the browser displays a **security warning** (e.g., “Your connection is not private”).
* This occurs because Ingress-NGINX uses a **self-signed certificate** for local development.

Steps to bypass:

1. Click **“Advanced”** or **“More Info”** at the bottom of the warning.
2. Choose **“Proceed anyway”** to continue to the site.

Then, in the browser’s address bar:

* Click on the **“Not secure”** label → **View certificate**.
  The certificate will read:

  ```
  Kubernetes Ingress Controller Fake Certificate
  ```

  This confirms that the connection is being handled by the local ingress controller.

> This warning only appears in local development.
> In production, a valid TLS certificate (e.g., from Let’s Encrypt) will replace the fake one.

---

#### 4. Testing Application Routing

* Access the Minikube IP in the browser.
* The frontend should load correctly.
* Perform a test (e.g., submit a form or input data).
* Refresh the page — expected result: the data is displayed, confirming both the **client** and **server** services are connected through Ingress.

Successful output indicates:

* The Ingress controller is running.
* Traffic routing rules are functioning as intended.
* The Kubernetes cluster is fully operational for local development.

---

#### 5. Next Step

With local routing verified, the next phase is preparing to **migrate the setup to a production environment** — specifically deploying the same configuration to a managed cloud Kubernetes service.
