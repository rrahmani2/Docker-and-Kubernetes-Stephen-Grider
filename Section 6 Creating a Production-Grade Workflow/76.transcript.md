Here’s the summary of what’s happening in this section:

---

### **Problem We’re Solving**

* Running tests inside a temporary container with `docker run` didn’t reflect live changes to files.
* Attaching to the main app container with `docker exec` worked, but was tedious—you had to grab the container ID and run the command manually each time.

---

### **Solution: Dedicated Test Service in Docker Compose**

* We add a **second service** in `docker-compose.yml` called something like `Tes` (or `test`).
* This service is configured to:

  1. **Build from the same Dockerfile** (`dockerfile.dev`) and context as the main app.
  2. **Use the same volume mappings**:

     * Placeholder for `node_modules` so container dependencies aren’t overridden.
     * Map the current project directory to `/app` inside the container.
  3. **Override the command** to run `npm run test` instead of `npm start`.
* Ports aren’t needed because this service doesn’t run a server.

---

### **Result**

* When you run:

  ```bash
  docker compose up --build
  ```

  * Two containers are created:

    1. The main app container for development.
    2. The test container, which watches volumes and reruns tests whenever source files change.
* Test changes are now reflected automatically without manual `docker exec` commands.

---

### **Limitations**

* This approach works, but the test container **doesn’t allow interactive input**:

  * You can’t press `enter`, `W`, or other keys inside the test suite.
  * All output is logged to the Docker Compose terminal interface.
* You can attach manually if needed, but that reintroduces some manual steps.

---

In short: this method automates rerunning tests on file changes via a dedicated service, but sacrifices interactivity.

If you want, I can show a **slightly improved approach** that combines live file updates **and** interactive test input without needing multiple commands. That’s usually the most developer-friendly setup. Do you want me to outline that?
