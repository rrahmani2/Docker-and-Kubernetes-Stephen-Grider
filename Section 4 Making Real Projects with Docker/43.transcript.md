**Synopsis:**
The Node.js container is running, but the web application was not accessible from the host because incoming traffic to port 8080 was not forwarded into the container. Port mapping (`-p`) resolves this by linking a port on the host to a port inside the container.

---

**Content:**

1. **Problem:**

   * Container runs Node.js server on port 8080, but accessing `http://localhost:8080` from the host fails.
   * By default, containers are isolated; incoming traffic from the host is **not routed** into the container.

2. **Solution:**

   * Use **port mapping** when running the container.
   * Syntax:

     ```
     docker run -p <host-port>:<container-port> <image-name>
     ```

     * Maps incoming traffic on `<host-port>` to `<container-port>` inside the container.
     * Only affects incoming requests; the container can still make outbound requests freely.

3. **Example:**

   * Map host port 8080 to container port 8080:

     ```
     docker run -p 8080:8080 <docker-id>/simpleweb
     ```
   * Open browser at `http://localhost:8080` → sees `Hi there`.

4. **Alternate port mapping:**

   * Host and container ports do not have to match:

     ```
     docker run -p 5000:8080 <docker-id>/simpleweb
     ```
   * Open browser at `http://localhost:5000` → request forwarded to container port 8080.

5. **Important note:**

   * If you change the container port, you must also update your Node.js app (`index.js`) to listen on the new port.
   * Port mapping is a **runtime configuration**, not a Dockerfile setting.

---

**Summary:**

* Incoming traffic to a container is isolated by default.
* `-p` flag in `docker run` forwards traffic from host port to container port.
* Host and container ports can differ.
* With correct port mapping, the Node.js application is accessible in the browser.
