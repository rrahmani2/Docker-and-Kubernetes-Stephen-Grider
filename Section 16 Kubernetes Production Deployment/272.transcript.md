### Automatic Version Tagging with Git SHA

#### Problem Recap

Kubernetes deployments do not update when images use the same tag (`latest`). To trigger redeployments, each image must have a **unique tag**. Manually setting version numbers is error-prone and inefficient — this must be automated.

---

#### Solution: Tagging with Git SHA

Each image will have **two tags**:

1. `latest` — ensures `kubectl apply -f k8s` pulls the newest images by default.
2. `<DOCKER_ID>/<image-name>:<GIT_SHA>` — provides a unique identifier for each build, allowing Kubernetes to detect updates.

---

#### Getting the Git SHA

```bash
git rev-parse HEAD
```

* Outputs the unique SHA for the latest commit.
* Each SHA represents the repository state at a specific point in time.
* This SHA will be used as the version tag for Docker images.

Example:

```bash
a3b4c7f9d1...
```

When applied:

```
<DOCKER_ID>/multi-client:a3b4c7f9d1
```

---

#### Dual Tagging Strategy

In `deploy.sh`, modify the build commands to apply **two tags**:

```bash
docker build -t <DOCKER_ID>/multi-client:latest \
             -t <DOCKER_ID>/multi-client:$GIT_SHA \
             -f ./client/Dockerfile ./client
```

Repeat for `server` and `worker` images.

* `latest` ensures any new environment (e.g., a new developer’s Minikube setup) always pulls the most recent image.
* `$GIT_SHA` ensures production deployments get a unique tag, forcing Kubernetes to redeploy updated pods.

---

#### Why Git SHA Tagging Helps Debugging

If a production deployment fails, you can:

1. Identify the image version with:

   ```bash
   kubectl get deployment client-deployment -o yaml | grep image:
   ```

   → e.g., `multi-client:a3b4c7f9d1`
2. Locally revert code to that exact version:

   ```bash
   git checkout a3b4c7f9d1
   ```

   This guarantees debugging is done on the same code running in production.

---

#### Summary

* **Two image tags:** `latest` and `<GIT_SHA>`
* **`latest`** supports easy re-deployments for new environments.
* **`<GIT_SHA>`** provides unique tagging for CI/CD and production updates.
* **Next step:** Update `.travis.yml` and `deploy.sh` to dynamically inject the Git SHA during image build and push operations.
