### Verifying Successful Deployment to Kubernetes via Travis CI

#### 1. Build Verification

* The Travis CI pipeline completed successfully on the second run.
* The build log confirmed that:

  * Docker images were built and pushed to **Docker Hub**.
  * `kubectl` commands executed against the **production Kubernetes cluster**.
* Any future build errors are likely due to minor typos; cross-checking against the GitHub repository can help resolve them.

#### 2. Verifying Docker Hub Images

* Open **Docker Hub** and review repositories (e.g., `multi-server`).
* Confirm that:

  * The **`latest`** tag and the **commit-specific tag** were updated recently.
  * This ensures two things:

    1. A permanent versioned backup of the image exists (commit tag).
    2. The `latest` tag always reflects the most recent production image.

#### 3. Verifying Kubernetes Deployments

* Open the **Kubernetes dashboard** → **Workloads** tab.
* Confirm deployments for all application components:

  * `client`, `server`, `worker`, `postgres`, and `redis`.
* Each deployment lists its managed pods and runtime metrics.
* Clicking into a deployment displays:

  * Associated pods.
  * Pod-level runtime and configuration details.

#### 4. Checking Kubernetes Services and Ingress

* In the **Services** tab:

  * Verify all **ClusterIP** services exist for each component.
  * Identify the **Ingress service**—it exposes:

    * `/` → client service route.
    * `/api` → server API route.
* These correspond to the paths defined in the `ingress-service.yaml` configuration.
* The **Ingress controller** (NGINX) uses this configuration to route traffic appropriately.

#### 5. Configuration and Secrets

* Under the **Configuration** section:

  * Check for `pgpassword` secret—used by PostgreSQL.
  * Confirm presence of ConfigMaps (to be discussed later).
  * Verify a **service account** for NGINX Ingress, created automatically by **Tiller** during setup.

#### 6. Persistent Storage Verification

* Navigate to **Storage** → confirm the **PersistentVolumeClaim (PVC)** for PostgreSQL exists.
* Click into it to view:

  * The associated **PersistentVolume (PV)** automatically provisioned.
* This ensures that PostgreSQL has durable, non-ephemeral storage even if pods restart.

#### 7. Application Access Test

* Go to **Services**, copy the external IP of the **Ingress load balancer**, and visit it in the browser.
* A **privacy warning** may appear (due to a self-signed certificate).

  * Click **Advanced → Proceed** to bypass it temporarily.
* Expected result:

  * The **React frontend** loads successfully.
  * Submitting values (e.g., entering `4`) updates and persists correctly—confirming full backend integration.

#### 8. Outcome

* The application is now fully deployed and functional within the Kubernetes production cluster.
* Next steps:

  1. Fix the HTTPS certificate issue.
  2. Test the CI/CD pipeline by making source code changes and verifying automatic redeployment to production.
