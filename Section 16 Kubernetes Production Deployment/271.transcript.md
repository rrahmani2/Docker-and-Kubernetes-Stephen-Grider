### `deploy.sh` — Initial Kubernetes Deployment Script

1. **Objective**
   The `deploy.sh` script automates:

   * Building all Docker images
   * Pushing them to Docker Hub
   * Applying Kubernetes configs
   * Setting updated images on deployments

   However, using the default `latest` tag introduces a deployment issue where Kubernetes does not detect image changes. This section identifies and explains that problem before applying the fix.

---

2. **Building Docker Images**

   ```bash
   docker build -t <DOCKER_ID>/multi-client -f ./client/Dockerfile ./client
   docker build -t <DOCKER_ID>/multi-server -f ./server/Dockerfile ./server
   docker build -t <DOCKER_ID>/multi-worker -f ./worker/Dockerfile ./worker
   ```

   * Each line builds an image for a service (`client`, `server`, `worker`) using its respective Dockerfile and context.
   * `-t` assigns a tag using `<DOCKER_ID>/<image-name>`.
   * The implicit tag `latest` is automatically applied since no explicit version tag is provided.

---

3. **Pushing Images to Docker Hub**

   ```bash
   docker push <DOCKER_ID>/multi-client
   docker push <DOCKER_ID>/multi-server
   docker push <DOCKER_ID>/multi-worker
   ```

   * Authentication is already handled by Travis (`docker login` in `.travis.yml`).
   * Each image is pushed with its current tag (`latest`).

---

4. **Applying Kubernetes Configurations**

   ```bash
   kubectl apply -f k8s
   ```

   * Applies all YAML manifests under the `k8s` directory (deployments, services, etc.).
   * `kubectl` is already configured through Google Cloud authentication in Travis, so no extra setup is needed.

---

5. **Imperative Image Update**

   ```bash
   kubectl set image deployments/server-deployment server=<DOCKER_ID>/multi-server
   ```

   * Forces an image update on the `server-deployment`.
   * The same pattern would apply to other deployments (`client-deployment`, `worker-deployment`).

---

6. **Problem — Kubernetes Not Detecting New Images**

   * Every image is currently tagged as `latest`.
   * Kubernetes compares the deployment’s image reference:

     ```
     <DOCKER_ID>/multi-server:latest
     ```

     and sees no change between old and new pushes.
   * As a result, the deployment **does not pull** the new image, since the tag value hasn’t changed.
   * Kubernetes only redeploys when it detects a new image tag or digest.

---

7. **Resolution (to be implemented next)**

   * Introduce **unique version tags** for each build (e.g., using commit SHA or build ID).
   * This ensures that each deployment references a **new, versioned image**, triggering Kubernetes to pull and apply the latest container.

---

**Summary:**
The current `deploy.sh` correctly builds, pushes, and applies configuration files but fails to trigger Kubernetes redeployment due to the reuse of the `latest` tag. The next step is to incorporate automatic version tagging for each build.
