### Final Google Cloud Configuration Before Deployment

Before deploying via Travis, a few manual steps must be done in **Google Cloud** to match your local Kubernetes setup — specifically, recreating the **Postgres password secret** that the multi-server and Postgres containers depend on.

---

#### 1. Purpose of the Secret

In your local Kubernetes setup, you previously created a secret named `pgpassword` that stored the environment variable `PGPASSWORD`.
Both the **multi-server deployment** and **Postgres pod** referenced this secret in their manifests.

Since secrets aren’t stored in Git (for security reasons), your Google Cloud cluster **doesn’t have it yet** — it must be created manually.

---

#### 2. Use Google Cloud Shell for Setup

You’ll use **Google Cloud Shell** — the browser-based terminal built into the GCP console.
It’s already authenticated and configured to manage your project resources.

Steps:

1. Go to your GCP Console dashboard.
2. Confirm the **multi-k8s** project is selected.
3. Click the **Activate Cloud Shell** icon (top-right of the console).
4. Wait for the shell to initialize — it will automatically open a terminal connected to your Google Cloud project.

---

#### 3. Configure `gcloud` for the Current Project

Inside the Cloud Shell, configure your environment to point to the correct project and zone, then fetch cluster credentials so that `kubectl` commands target the right cluster.

Run the following commands:

```bash
# Set your active project
gcloud config set project <PROJECT_ID>

# Set your compute zone (based on cluster location)
gcloud config set compute/zone us-central1-a

# Retrieve cluster credentials for kubectl
gcloud container clusters get-credentials multi-cluster
```

Replace `<PROJECT_ID>` with your actual GCP project ID (visible under your project name in the dropdown at the top of the console).

**Notes:**

* These commands only need to be run **once per cluster** (or again if you create a new cluster or project).
* After completion, your Cloud Shell `kubectl` context will be connected to the target cluster.

---

#### 4. Create the Kubernetes Secret

Once your Cloud Shell is configured, create the same secret as used locally.
Run the following command, substituting your actual password:

```bash
kubectl create secret generic pgpassword --from-literal PGPASSWORD=<your_database_password>
```

Example:

```bash
kubectl create secret generic pgpassword --from-literal PGPASSWORD=postgres123
```

This will create a secret resource named **pgpassword** that holds the key-value pair `PGPASSWORD=<your_password>`.

You can verify it with:

```bash
kubectl get secrets
```

And confirm its existence:

```bash
kubectl describe secret pgpassword
```

---

#### 5. Why This Step Matters

* Without this secret, your **multi-server** and **Postgres** pods will fail to start — both rely on the environment variable defined in their deployment manifests:

  ```yaml
  env:
    - name: PGPASSWORD
      valueFrom:
        secretKeyRef:
          name: pgpassword
          key: PGPASSWORD
  ```
* The secret **must exist in the same namespace** as the deployments that use it.

---

#### ✅ Summary

| Step | Action             | Command                                                                              |
| ---- | ------------------ | ------------------------------------------------------------------------------------ |
| 1    | Open Cloud Shell   | (Click Cloud Shell icon in GCP Console)                                              |
| 2    | Set Project        | `gcloud config set project <PROJECT_ID>`                                             |
| 3    | Set Zone           | `gcloud config set compute/zone us-central1-a`                                       |
| 4    | Connect to Cluster | `gcloud container clusters get-credentials multi-cluster`                            |
| 5    | Create Secret      | `kubectl create secret generic pgpassword --from-literal PGPASSWORD=<your_password>` |

After this setup, your Kubernetes cluster will be fully prepared to accept deployments triggered automatically by Travis CI.
