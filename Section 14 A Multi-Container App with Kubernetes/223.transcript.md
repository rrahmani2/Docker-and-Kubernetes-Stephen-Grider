### Kubernetes — Understanding **Volumes**, **PersistentVolumes**, and Why We Don’t Use Plain Volumes for Databases

#### **1. Context**

In the previous section, we discussed how **volumes** allow containers to persist data outside their internal file system — essential for databases like PostgreSQL that must retain data after restarts.
Now we’re focusing on **how Kubernetes handles volumes**, clarifying the distinction between:

* **Volumes**
* **PersistentVolumes (PV)**
* **PersistentVolumeClaims (PVC)**

---

### **2. “Volume” in Kubernetes — A Specific Object Type**

In Kubernetes, the term **“volume”** doesn’t refer generically to storage like it does in Docker.
Instead, it’s a **Kubernetes object** — just like a `Deployment` or a `Service`.

**Definition:**

> A **Kubernetes Volume** is an object that provides temporary, pod-scoped storage.

You can define it inside a pod specification, and it allows containers within that pod to share or persist data.

Example:

* A pod contains a **PostgreSQL container**.
* A Kubernetes **Volume** is defined within the pod.
* The PostgreSQL container writes data to that volume.

---

### **3. Volume Behavior and Limitations**

**Behavior:**

* The volume **belongs to the pod**.
* It can be accessed by **all containers** in that pod.
* If a container inside the pod crashes, Kubernetes recreates it — the **volume remains intact**, and the new container regains access to the same data.

**Limitation:**

* If the **pod itself** is deleted or recreated, the **volume is destroyed**.
* The volume’s lifecycle is **tied to the pod’s lifecycle**.
* When a Deployment recreates a pod (e.g., after a crash or update), the new pod gets a **fresh volume**, meaning **all data is lost**.

---

### **4. Why Plain Kubernetes Volumes Are Not Enough for Databases**

Databases (like PostgreSQL) must retain data even if:

* The pod is deleted,
* The cluster restarts,
* The Deployment rolls out an update.

Because a Kubernetes **volume** is destroyed with its pod, it’s **not suitable for persistent database storage**.
It only ensures data survives **container restarts**, not **pod recreations**.

---

### **5. Example Scenario**

| Event                                                 | What Happens to Volume         | Data Persistence |
| ----------------------------------------------------- | ------------------------------ | ---------------- |
| **Container restart** inside pod                      | Volume survives                | ✅ Data persists  |
| **Pod restart** (deleted and recreated by Deployment) | Volume destroyed and recreated | ❌ Data lost      |
| **Node failure / pod rescheduled elsewhere**          | Volume lost                    | ❌ Data lost      |

---

### **6. Summary**

| Concept                         | Scope          | Survives Pod Restart? | Use Case                                                       |
| ------------------------------- | -------------- | --------------------- | -------------------------------------------------------------- |
| **Volume**                      | Pod-level      | ❌ No                  | Temporary storage, sharing data between containers in same pod |
| **PersistentVolume (PV)**       | Cluster-level  | ✅ Yes                 | Long-term persistent storage                                   |
| **PersistentVolumeClaim (PVC)** | Request for PV | ✅ Yes                 | Pod-level abstraction to claim persistent storage              |

---

### **7. Takeaway**

* A Kubernetes **Volume** is ephemeral — tied to the **pod’s lifecycle**.
* For databases like PostgreSQL, we need data persistence **beyond pod restarts**.
* Therefore, we’ll use **PersistentVolumes (PVs)** and **PersistentVolumeClaims (PVCs)**, which provide **durable, cluster-level storage** that survives pod deletion.

---

### **Next Step**

In the following section, we’ll explore:

* What exactly a **PersistentVolume (PV)** is,
* How it’s different from a regular volume,
* And how a **PersistentVolumeClaim (PVC)** requests and binds to it.
