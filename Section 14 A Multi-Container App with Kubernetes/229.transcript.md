### Integrating Persistent Volume Claim with Postgres Deployment – Technical Notes

#### 1. Objective

Link the **PersistentVolumeClaim (PVC)** to the **Postgres Deployment** so the pod requests and uses long-term storage that satisfies the claim’s specifications.

---

#### 2. Update to Deployment Template

Inside the Postgres Deployment YAML, locate the `template` → `spec` section (which defines the pod template for the deployment). Add the following configuration:

```yaml
spec:
  volumes:
    - name: postgres-storage
      persistentVolumeClaim:
        claimName: database-persistent-volume-claim
```

**Explanation:**

* `volumes`: Declares a list of volumes accessible to containers within the pod.
* `name`: Logical identifier for this storage reference.
* `persistentVolumeClaim`: Specifies that this volume is sourced from an existing PVC.
* `claimName`: Must match the name of the PVC defined earlier (`database-persistent-volume-claim`).

This tells Kubernetes:

> “When creating this pod, attach a persistent volume that meets the requirements of this claim (2 GiB, ReadWriteOnce).”

Kubernetes then allocates appropriate storage — from the local disk (Minikube) or from the cloud provider’s storage backend (AWS EBS, GCP Persistent Disk, etc.).

---

#### 3. Mounting the Volume in the Container

Within the same pod template, under the container specification (`containers:` section), add the `volumeMounts` configuration:

```yaml
containers:
  - name: postgres
    image: postgres:latest
    ports:
      - containerPort: 5432
    volumeMounts:
      - name: postgres-storage
        mountPath: /var/lib/postgresql/data
        subPath: postgres
```

**Explanation:**

* `volumeMounts`: Defines where the requested volume should be mounted inside the container filesystem.
* `name`: Must match the volume name declared earlier (`postgres-storage`).
* `mountPath`: The directory inside the container where the volume will be mounted.

  * `/var/lib/postgresql/data` is the default data directory for Postgres — all database files are stored here.
* `subPath`: Ensures data is stored within a subdirectory (`postgres`) inside the persistent volume.

  * This prevents Postgres startup errors related to mounting behavior when it detects non-empty directories.

---

#### 4. Lifecycle Summary

| Component                          | Purpose                                                    | Key Detail                             |
| ---------------------------------- | ---------------------------------------------------------- | -------------------------------------- |
| **PersistentVolumeClaim (PVC)**    | Advertises required storage size and access mode           | Example: 2 GiB, ReadWriteOnce          |
| **Pod Volume Section**             | Requests and attaches a volume from the PVC                | Uses `persistentVolumeClaim` reference |
| **Container VolumeMounts Section** | Specifies where the volume is mounted inside the container | Mounts `/var/lib/postgresql/data`      |

---

#### 5. Operational Flow

1. Pod creation triggers a request for storage defined in the PVC.
2. Kubernetes locates or provisions a matching **PersistentVolume (PV)**.
3. The PV is attached to the pod.
4. Postgres uses the mounted directory to store database files persistently.
5. If the pod or container restarts, the data remains intact since it resides on the persistent volume.

---

#### 6. Key Takeaway

* `volumes` connects the pod to the PVC.
* `volumeMounts` integrates that storage into the container’s filesystem.
* Using `subPath` ensures Postgres initializes correctly within a mounted directory.

This configuration provides **persistent, durable database storage** across pod or container restarts.
