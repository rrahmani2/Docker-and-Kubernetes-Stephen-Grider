### Transition from Docker Compose to Kubernetes – Project Preparation

**Objective:**
Begin refactoring the multi-container “complex” application for Kubernetes deployment by cleaning the project directory and creating the first Kubernetes manifest.

---

### 1. Pre-Migration Preparation

* Stop the running Docker Compose setup.
* Back up the **complex project directory** before making any changes.

  * Example backup name: `complex-elastic-beanstalk`.
  * Alternatively, use Git for version control.

---

### 2. Remove Unnecessary Files and Folders

The following are no longer required for the Kubernetes setup:

* `travis.yml` – will be recreated later for the Kubernetes CI/CD pipeline.
* `docker-compose.yml` – replaced by Kubernetes deployments and services.
* Any **Docker run scripts**.
* The `nginx/` directory – previously handled routing; in Kubernetes, routing will be managed using an **Ingress service**.

After cleanup, the project should contain only:

```
client/
server/
worker/
```

---

### 3. Create Kubernetes Configuration Directory

* Inside the project root, create a new folder:

  ```
  mkdir K8s
  ```
* All Kubernetes manifests (YAML files) will reside here.
* Expected total: **~11 configuration files**, covering deployments, services, and storage definitions (PVCs).

---

### 4. Create the Client Deployment Manifest

**File:** `K8s/client-deployment.yml`

This manifest defines the frontend (React client) deployment, which manages 3 pod replicas running the multi-client image.

**YAML Structure Overview:**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: client-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      component: web
  template:
    metadata:
      labels:
        component: web
    spec:
      containers:
        - name: client
          image: <your-docker-id>/multi-client
          ports:
            - containerPort: 3000
```

**Explanation:**

* `apiVersion: apps/v1` — specifies the API version for Deployments.
* `kind: Deployment` — defines this file as a deployment object.
* `metadata.name` — name assigned to this deployment (`client-deployment`).
* `spec.replicas: 3` — ensures three replicas of the frontend pod are maintained.
* `selector.matchLabels` and `template.metadata.labels` — link pods to their managing deployment using the `component: web` label.
* `containers` — defines the pod contents.

  * `name: client` — container name.
  * `image` — Docker image for the frontend (`multi-client`).
  * `containerPort: 3000` — exposes port 3000 for the frontend service.

---

### 5. Next Step

In the following phase, create a **ClusterIP Service** for the client deployment and understand how **ClusterIP** differs from **NodePort** services.
