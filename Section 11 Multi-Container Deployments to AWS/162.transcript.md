That section finishes the **AWS setup** by configuring **environment variables in Elastic Beanstalk**, so your containers can find and connect to **RDS (PostgreSQL)** and **ElastiCache (Redis)** through their private endpoints.

Hereâ€™s the technical breakdown of whatâ€™s actually happening and what you need to set up:

---

## ðŸ§© Goal

Your **Elastic Beanstalk (EB)** app (which runs your Docker containers) needs to know:

* How to reach **Redis (ElastiCache)**
* How to reach **Postgres (RDS)**
* The login credentials and ports for both

In your local setup (via `docker-compose.yml`), these were defined as environment variables.
Now youâ€™re recreating those same variables inside the **EB environment configuration**.

---

## âš™ï¸ Step-by-Step Configuration

### 1. Go to Environment Properties in Elastic Beanstalk

**Path:**

```
Elastic Beanstalk â†’ Environments â†’ [Your Environment]
â†’ Configuration â†’ Software â†’ Modify
â†’ Scroll to Environment Properties
```

This section is where youâ€™ll define all the variables your containers need.

---

### 2. Add Redis Variables

| Variable Name | Value                                                  |
| ------------- | ------------------------------------------------------ |
| `REDIS_HOST`  | *Primary endpoint of ElastiCache Redis (without port)* |
| `REDIS_PORT`  | `6379`                                                 |

**How to get the Redis endpoint:**

* Go to **ElastiCache â†’ Redis â†’ your cluster**
* Expand it â†’ look for **Primary Endpoint**
* Copy **everything before `:6379`** (omit the port)

Example:

```
Primary Endpoint: mycache.xxxxx.use1.cache.amazonaws.com:6379
```

Use:

```
REDIS_HOST = mycache.xxxxx.use1.cache.amazonaws.com
REDIS_PORT = 6379
```

---

### 3. Add PostgreSQL Variables

| Variable Name | Value                                                |
| ------------- | ---------------------------------------------------- |
| `PGUSER`      | `postgres` *(or whatever you set when creating RDS)* |
| `PGPASSWORD`  | your Postgres password                               |
| `PGHOST`      | RDS endpoint                                         |
| `PGDATABASE`  | your database name (e.g. `fibvalues`)                |
| `PGPORT`      | `5432`                                               |

**How to get the RDS endpoint:**

* Go to **RDS â†’ Databases â†’ multi-docker-postgres â†’ Connectivity & security**
* Under **Endpoint & port**, copy the endpoint (not the port)

Example:

```
Endpoint: mydb.xxxxxx.us-east-1.rds.amazonaws.com
```

Use:

```
PGHOST = mydb.xxxxxx.us-east-1.rds.amazonaws.com
```

---

### âš ï¸ Important Notes

* **Double-check every variable name and value.**
  Typos here are the #1 cause of deployment failures.

* **Donâ€™t include colons or ports in hostnames.**
  (`:6379` or `:5432` should never appear in the `HOST` values.)

* **Elastic Beanstalk does *not* mask environment variable values** â€” meaning your DB password is visible in the console.
  Itâ€™s a known design flaw. AWS recommends using **AWS Systems Manager Parameter Store** or **Secrets Manager** for production deployments â€” but for this tutorial, plain environment variables are fine.

---

### âœ… Result

Once you click **Apply**, Elastic Beanstalk will:

* Restart your EC2 instances.
* Inject all these environment variables into **every container** defined in your `Dockerrun.aws.json`.

That means:

* The **API container** can connect to Postgres (`PG*` vars) and Redis (`REDIS*` vars).
* The **Worker container** can connect to Redis.
* You **donâ€™t** need to map variables per container â€” EB handles it globally.

---

### ðŸ”š Next Step

Now that your EB environment knows where your database and cache live, the next (and final) step is:

> Updating `.travis.yml` to automatically trigger a new Elastic Beanstalk deployment after Docker images are built and pushed to Docker Hub.

Would you like me to break down exactly what those `.travis.yml` changes should look like?
